Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> pgm
Rule 1     pgm -> DeclSeq
Rule 2     DeclSeq -> Decl DeclSeq
Rule 3     DeclSeq -> empty
Rule 4     empty -> <empty>
Rule 5     Decl -> VarDecl
Rule 6     Extension -> VarDecl
Rule 7     Extension -> VarDecl Extension
Rule 8     Extension -> stmtSeq
Rule 9     Decl -> FunDecl
Rule 10    Decl -> ClassDecl
Rule 11    VarDecl -> Type VarList SCOLON
Rule 12    stmtSeq -> stmt stmtSeq
Rule 13    stmtSeq -> empty
Rule 14    Type -> INT
Rule 15    Type -> BOOL
Rule 16    Type -> ID
Rule 17    Type -> VOID
Rule 18    VarList -> Var COMMA VarList
Rule 19    VarList -> Var
Rule 20    Var -> ID DimStar
Rule 21    DimStar -> LBRACKET RBRACKET
Rule 22    FunDecl -> Type ID LPAREN fseen FormalOpt RPAREN stmt
Rule 23    fseen -> empty
Rule 24    FormalOpt -> Type ID
Rule 25    FormalOpt -> empty
Rule 26    FunctionCall -> ID LPAREN Args RPAREN
Rule 27    Args -> AE
Rule 28    Args -> empty
Rule 29    ClassDecl -> CLASS ID LBRACE Extension RBRACE
Rule 30    DimStar -> empty
Rule 31    DimStar -> LBRACKET RBRACKET DimStar
Rule 32    stmt -> matchedstmt
Rule 33    stmt -> openstmt
Rule 34    matchedstmt -> SE SCOLON
Rule 35    matchedstmt -> Print
Rule 36    matchedstmt -> While
Rule 37    matchedstmt -> Block
Rule 38    matchedstmt -> doWhile
Rule 39    matchedstmt -> for
Rule 40    matchedstmt -> ReturnOpt SCOLON
Rule 41    ReturnOpt -> RETURN AE
Rule 42    ReturnOpt -> RETURN VOID
Rule 43    openstmt -> IF AE THEN stmt
Rule 44    openstmt -> IF AE THEN matchedstmt ELSE openstmt
Rule 45    matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt
Rule 46    SE -> LHS EQUALS AE
Rule 47    LHS -> FieldAccess
Rule 48    LHS -> ArrayAccess
Rule 49    FieldAccess -> ID
Rule 50    FieldAccess -> Primary DOT ID
Rule 51    SE -> INCREMENT LHS
Rule 52    SE -> DECREMENT LHS
Rule 53    Print -> PRINT LPAREN AE RPAREN SCOLON
Rule 54    While -> WHILE AE DO matchedstmt
Rule 55    doWhile -> DO matchedstmt WHILE AE SCOLON
Rule 56    for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
Rule 57    SEopt -> SE
Rule 58    SEopt -> empty
Rule 59    AEopt -> AE
Rule 60    AEopt -> empty
Rule 61    AE -> SE
Rule 62    AE -> Primary
Rule 63    Primary -> FieldAccess
Rule 64    Primary -> FunctionCall
Rule 65    Primary -> INPUT LPAREN RPAREN
Rule 66    Primary -> TRUE
Rule 67    Primary -> FALSE
Rule 68    Primary -> LPAREN AE RPAREN
Rule 69    Primary -> NUMBER
Rule 70    AE -> AE PLUS AE
Rule 71    AE -> AE MINUS AE
Rule 72    AE -> AE MULT AE
Rule 73    AE -> AE DIVIDE AE
Rule 74    AE -> AE MOD AE
Rule 75    AE -> MINUS AE
Rule 76    AE -> AE GREATERTHAN AE
Rule 77    AE -> AE GREATEROREQUAL AE
Rule 78    AE -> AE LESSTHAN AE
Rule 79    AE -> AE LESSOREQUAL AE
Rule 80    AE -> AE ISEQUAL AE
Rule 81    AE -> AE NOTEQUAL AE
Rule 82    AE -> AE AND AE
Rule 83    AE -> AE OR AE
Rule 84    AE -> NOT AE
Rule 85    Primary -> ArrayAccess
Rule 86    Primary -> NEW ID LPAREN RPAREN
Rule 87    AE -> NEW Type DimExpr DimStar
Rule 88    ArrayAccess -> Primary LBRACKET AE RBRACKET
Rule 89    DimExpr -> LBRACKET AE RBRACKET
Rule 90    Block -> LBRACE seen Extension RBRACE
Rule 91    seen -> <empty>

Terminals, with rules where they appear

AND                  : 82
BOOL                 : 15
CLASS                : 29
COMMA                : 18
DECREMENT            : 52
DIVIDE               : 73
DO                   : 54 55
DOT                  : 50
ELSE                 : 44 45
EQUALS               : 46
FALSE                : 67
FOR                  : 56
GREATEROREQUAL       : 77
GREATERTHAN          : 76
ID                   : 16 20 22 24 26 29 49 50 86
IF                   : 43 44 45
INCREMENT            : 51
INPUT                : 65
INT                  : 14
ISEQUAL              : 80
LBRACE               : 29 90
LBRACKET             : 21 31 88 89
LESSOREQUAL          : 79
LESSTHAN             : 78
LPAREN               : 22 26 53 56 65 68 86
MINUS                : 71 75
MOD                  : 74
MULT                 : 72
NEW                  : 86 87
NOT                  : 84
NOTEQUAL             : 81
NUMBER               : 69
OR                   : 83
PLUS                 : 70
PRINT                : 53
RBRACE               : 29 90
RBRACKET             : 21 31 88 89
RETURN               : 41 42
RPAREN               : 22 26 53 56 65 68 86
SCOLON               : 11 34 40 53 55 56 56
THEN                 : 43 44 45
TRUE                 : 66
VOID                 : 17 42
WHILE                : 54 55
error                : 

Nonterminals, with rules where they appear

AE                   : 27 41 43 44 45 46 53 54 55 59 68 70 70 71 71 72 72 73 73 74 74 75 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 84 88 89
AEopt                : 56
Args                 : 26
ArrayAccess          : 48 85
Block                : 37
ClassDecl            : 10
Decl                 : 2
DeclSeq              : 1 2
DimExpr              : 87
DimStar              : 20 31 87
Extension            : 7 29 90
FieldAccess          : 47 63
FormalOpt            : 22
FunDecl              : 9
FunctionCall         : 64
LHS                  : 46 51 52
Primary              : 50 62 88
Print                : 35
ReturnOpt            : 40
SE                   : 34 57 61
SEopt                : 56 56
Type                 : 11 22 24 87
Var                  : 18 19
VarDecl              : 5 6 7
VarList              : 11 18
While                : 36
doWhile              : 38
empty                : 3 13 23 25 28 30 58 60
for                  : 39
fseen                : 22
matchedstmt          : 32 44 45 45 54 55 56
openstmt             : 33 44
pgm                  : 0
seen                 : 90
stmt                 : 12 22 43
stmtSeq              : 8 12

Parsing method: LALR

state 0

    (0) S' -> . pgm
    (1) pgm -> . DeclSeq
    (2) DeclSeq -> . Decl DeclSeq
    (3) DeclSeq -> . empty
    (5) Decl -> . VarDecl
    (9) Decl -> . FunDecl
    (10) Decl -> . ClassDecl
    (4) empty -> .
    (11) VarDecl -> . Type VarList SCOLON
    (22) FunDecl -> . Type ID LPAREN fseen FormalOpt RPAREN stmt
    (29) ClassDecl -> . CLASS ID LBRACE Extension RBRACE
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . ID
    (17) Type -> . VOID

    $end            reduce using rule 4 (empty -> .)
    CLASS           shift and go to state 6
    INT             shift and go to state 11
    BOOL            shift and go to state 12
    ID              shift and go to state 8
    VOID            shift and go to state 1

    Decl                           shift and go to state 9
    ClassDecl                      shift and go to state 4
    VarDecl                        shift and go to state 10
    pgm                            shift and go to state 2
    FunDecl                        shift and go to state 5
    DeclSeq                        shift and go to state 13
    Type                           shift and go to state 3
    empty                          shift and go to state 7

state 1

    (17) Type -> VOID .

    LBRACKET        reduce using rule 17 (Type -> VOID .)
    ID              reduce using rule 17 (Type -> VOID .)


state 2

    (0) S' -> pgm .



state 3

    (11) VarDecl -> Type . VarList SCOLON
    (22) FunDecl -> Type . ID LPAREN fseen FormalOpt RPAREN stmt
    (18) VarList -> . Var COMMA VarList
    (19) VarList -> . Var
    (20) Var -> . ID DimStar

    ID              shift and go to state 16

    VarList                        shift and go to state 14
    Var                            shift and go to state 15

state 4

    (10) Decl -> ClassDecl .

    CLASS           reduce using rule 10 (Decl -> ClassDecl .)
    INT             reduce using rule 10 (Decl -> ClassDecl .)
    BOOL            reduce using rule 10 (Decl -> ClassDecl .)
    ID              reduce using rule 10 (Decl -> ClassDecl .)
    VOID            reduce using rule 10 (Decl -> ClassDecl .)
    $end            reduce using rule 10 (Decl -> ClassDecl .)


state 5

    (9) Decl -> FunDecl .

    CLASS           reduce using rule 9 (Decl -> FunDecl .)
    INT             reduce using rule 9 (Decl -> FunDecl .)
    BOOL            reduce using rule 9 (Decl -> FunDecl .)
    ID              reduce using rule 9 (Decl -> FunDecl .)
    VOID            reduce using rule 9 (Decl -> FunDecl .)
    $end            reduce using rule 9 (Decl -> FunDecl .)


state 6

    (29) ClassDecl -> CLASS . ID LBRACE Extension RBRACE

    ID              shift and go to state 17


state 7

    (3) DeclSeq -> empty .

    $end            reduce using rule 3 (DeclSeq -> empty .)


state 8

    (16) Type -> ID .

    ID              reduce using rule 16 (Type -> ID .)


state 9

    (2) DeclSeq -> Decl . DeclSeq
    (2) DeclSeq -> . Decl DeclSeq
    (3) DeclSeq -> . empty
    (5) Decl -> . VarDecl
    (9) Decl -> . FunDecl
    (10) Decl -> . ClassDecl
    (4) empty -> .
    (11) VarDecl -> . Type VarList SCOLON
    (22) FunDecl -> . Type ID LPAREN fseen FormalOpt RPAREN stmt
    (29) ClassDecl -> . CLASS ID LBRACE Extension RBRACE
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . ID
    (17) Type -> . VOID

    $end            reduce using rule 4 (empty -> .)
    CLASS           shift and go to state 6
    INT             shift and go to state 11
    BOOL            shift and go to state 12
    ID              shift and go to state 8
    VOID            shift and go to state 1

    Decl                           shift and go to state 9
    ClassDecl                      shift and go to state 4
    VarDecl                        shift and go to state 10
    FunDecl                        shift and go to state 5
    DeclSeq                        shift and go to state 18
    Type                           shift and go to state 3
    empty                          shift and go to state 7

state 10

    (5) Decl -> VarDecl .

    CLASS           reduce using rule 5 (Decl -> VarDecl .)
    INT             reduce using rule 5 (Decl -> VarDecl .)
    BOOL            reduce using rule 5 (Decl -> VarDecl .)
    ID              reduce using rule 5 (Decl -> VarDecl .)
    VOID            reduce using rule 5 (Decl -> VarDecl .)
    $end            reduce using rule 5 (Decl -> VarDecl .)


state 11

    (14) Type -> INT .

    LBRACKET        reduce using rule 14 (Type -> INT .)
    ID              reduce using rule 14 (Type -> INT .)


state 12

    (15) Type -> BOOL .

    LBRACKET        reduce using rule 15 (Type -> BOOL .)
    ID              reduce using rule 15 (Type -> BOOL .)


state 13

    (1) pgm -> DeclSeq .

    $end            reduce using rule 1 (pgm -> DeclSeq .)


state 14

    (11) VarDecl -> Type VarList . SCOLON

    SCOLON          shift and go to state 19


state 15

    (18) VarList -> Var . COMMA VarList
    (19) VarList -> Var .

    COMMA           shift and go to state 20
    SCOLON          reduce using rule 19 (VarList -> Var .)


state 16

    (22) FunDecl -> Type ID . LPAREN fseen FormalOpt RPAREN stmt
    (20) Var -> ID . DimStar
    (21) DimStar -> . LBRACKET RBRACKET
    (30) DimStar -> . empty
    (31) DimStar -> . LBRACKET RBRACKET DimStar
    (4) empty -> .

    LPAREN          shift and go to state 22
    LBRACKET        shift and go to state 21
    COMMA           reduce using rule 4 (empty -> .)
    SCOLON          reduce using rule 4 (empty -> .)

    empty                          shift and go to state 23
    DimStar                        shift and go to state 24

state 17

    (29) ClassDecl -> CLASS ID . LBRACE Extension RBRACE

    LBRACE          shift and go to state 25


state 18

    (2) DeclSeq -> Decl DeclSeq .

    $end            reduce using rule 2 (DeclSeq -> Decl DeclSeq .)


state 19

    (11) VarDecl -> Type VarList SCOLON .

    CLASS           reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    INT             reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    BOOL            reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    ID              reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    VOID            reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    $end            reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    IF              reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    INCREMENT       reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    DECREMENT       reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    PRINT           reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    WHILE           reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    LBRACE          reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    DO              reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    FOR             reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    RETURN          reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    INPUT           reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    TRUE            reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    FALSE           reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    LPAREN          reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    NUMBER          reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    NEW             reduce using rule 11 (VarDecl -> Type VarList SCOLON .)
    RBRACE          reduce using rule 11 (VarDecl -> Type VarList SCOLON .)


state 20

    (18) VarList -> Var COMMA . VarList
    (18) VarList -> . Var COMMA VarList
    (19) VarList -> . Var
    (20) Var -> . ID DimStar

    ID              shift and go to state 27

    Var                            shift and go to state 15
    VarList                        shift and go to state 26

state 21

    (21) DimStar -> LBRACKET . RBRACKET
    (31) DimStar -> LBRACKET . RBRACKET DimStar

    RBRACKET        shift and go to state 28


state 22

    (22) FunDecl -> Type ID LPAREN . fseen FormalOpt RPAREN stmt
    (23) fseen -> . empty
    (4) empty -> .

    INT             reduce using rule 4 (empty -> .)
    BOOL            reduce using rule 4 (empty -> .)
    ID              reduce using rule 4 (empty -> .)
    VOID            reduce using rule 4 (empty -> .)
    RPAREN          reduce using rule 4 (empty -> .)

    empty                          shift and go to state 30
    fseen                          shift and go to state 29

state 23

    (30) DimStar -> empty .

    COMMA           reduce using rule 30 (DimStar -> empty .)
    SCOLON          reduce using rule 30 (DimStar -> empty .)
    PLUS            reduce using rule 30 (DimStar -> empty .)
    MINUS           reduce using rule 30 (DimStar -> empty .)
    MULT            reduce using rule 30 (DimStar -> empty .)
    DIVIDE          reduce using rule 30 (DimStar -> empty .)
    MOD             reduce using rule 30 (DimStar -> empty .)
    GREATERTHAN     reduce using rule 30 (DimStar -> empty .)
    GREATEROREQUAL  reduce using rule 30 (DimStar -> empty .)
    LESSTHAN        reduce using rule 30 (DimStar -> empty .)
    LESSOREQUAL     reduce using rule 30 (DimStar -> empty .)
    ISEQUAL         reduce using rule 30 (DimStar -> empty .)
    NOTEQUAL        reduce using rule 30 (DimStar -> empty .)
    AND             reduce using rule 30 (DimStar -> empty .)
    OR              reduce using rule 30 (DimStar -> empty .)
    DO              reduce using rule 30 (DimStar -> empty .)
    RPAREN          reduce using rule 30 (DimStar -> empty .)
    THEN            reduce using rule 30 (DimStar -> empty .)
    RBRACKET        reduce using rule 30 (DimStar -> empty .)


state 24

    (20) Var -> ID DimStar .

    COMMA           reduce using rule 20 (Var -> ID DimStar .)
    SCOLON          reduce using rule 20 (Var -> ID DimStar .)


state 25

    (29) ClassDecl -> CLASS ID LBRACE . Extension RBRACE
    (6) Extension -> . VarDecl
    (7) Extension -> . VarDecl Extension
    (8) Extension -> . stmtSeq
    (11) VarDecl -> . Type VarList SCOLON
    (12) stmtSeq -> . stmt stmtSeq
    (13) stmtSeq -> . empty
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . ID
    (17) Type -> . VOID
    (32) stmt -> . matchedstmt
    (33) stmt -> . openstmt
    (4) empty -> .
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (43) openstmt -> . IF AE THEN stmt
    (44) openstmt -> . IF AE THEN matchedstmt ELSE openstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    INT             shift and go to state 11
    BOOL            shift and go to state 12
    ID              shift and go to state 57
    VOID            shift and go to state 1
    RBRACE          reduce using rule 4 (empty -> .)
    IF              shift and go to state 59
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    doWhile                        shift and go to state 35
    Print                          shift and go to state 38
    openstmt                       shift and go to state 39
    Type                           shift and go to state 40
    for                            shift and go to state 42
    empty                          shift and go to state 48
    Extension                      shift and go to state 49
    stmt                           shift and go to state 50
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    matchedstmt                    shift and go to state 54
    ArrayAccess                    shift and go to state 55
    ReturnOpt                      shift and go to state 56
    Block                          shift and go to state 58
    FieldAccess                    shift and go to state 62
    VarDecl                        shift and go to state 63
    Primary                        shift and go to state 34
    stmtSeq                        shift and go to state 64
    FunctionCall                   shift and go to state 47
    SE                             shift and go to state 66

state 26

    (18) VarList -> Var COMMA VarList .

    SCOLON          reduce using rule 18 (VarList -> Var COMMA VarList .)


state 27

    (20) Var -> ID . DimStar
    (21) DimStar -> . LBRACKET RBRACKET
    (30) DimStar -> . empty
    (31) DimStar -> . LBRACKET RBRACKET DimStar
    (4) empty -> .

    LBRACKET        shift and go to state 21
    COMMA           reduce using rule 4 (empty -> .)
    SCOLON          reduce using rule 4 (empty -> .)

    DimStar                        shift and go to state 24
    empty                          shift and go to state 23

state 28

    (21) DimStar -> LBRACKET RBRACKET .
    (31) DimStar -> LBRACKET RBRACKET . DimStar
    (21) DimStar -> . LBRACKET RBRACKET
    (30) DimStar -> . empty
    (31) DimStar -> . LBRACKET RBRACKET DimStar
    (4) empty -> .

  ! reduce/reduce conflict for COMMA resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for SCOLON resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for PLUS resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for MULT resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for MOD resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for GREATERTHAN resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for GREATEROREQUAL resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for LESSOREQUAL resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for ISEQUAL resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for AND resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for OR resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for DO resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for THEN resolved using rule 4 (empty -> .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 4 (empty -> .)
    LBRACKET        shift and go to state 21
    COMMA           reduce using rule 4 (empty -> .)
    SCOLON          reduce using rule 4 (empty -> .)
    PLUS            reduce using rule 4 (empty -> .)
    MINUS           reduce using rule 4 (empty -> .)
    MULT            reduce using rule 4 (empty -> .)
    DIVIDE          reduce using rule 4 (empty -> .)
    MOD             reduce using rule 4 (empty -> .)
    GREATERTHAN     reduce using rule 4 (empty -> .)
    GREATEROREQUAL  reduce using rule 4 (empty -> .)
    LESSTHAN        reduce using rule 4 (empty -> .)
    LESSOREQUAL     reduce using rule 4 (empty -> .)
    ISEQUAL         reduce using rule 4 (empty -> .)
    NOTEQUAL        reduce using rule 4 (empty -> .)
    AND             reduce using rule 4 (empty -> .)
    OR              reduce using rule 4 (empty -> .)
    DO              reduce using rule 4 (empty -> .)
    RPAREN          reduce using rule 4 (empty -> .)
    THEN            reduce using rule 4 (empty -> .)
    RBRACKET        reduce using rule 4 (empty -> .)

  ! COMMA           [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! SCOLON          [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! PLUS            [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! MINUS           [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! MULT            [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! DIVIDE          [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! MOD             [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! GREATERTHAN     [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! GREATEROREQUAL  [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! LESSTHAN        [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! LESSOREQUAL     [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! ISEQUAL         [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! NOTEQUAL        [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! AND             [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! OR              [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! DO              [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! RPAREN          [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! THEN            [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]
  ! RBRACKET        [ reduce using rule 21 (DimStar -> LBRACKET RBRACKET .) ]

    DimStar                        shift and go to state 67
    empty                          shift and go to state 23

state 29

    (22) FunDecl -> Type ID LPAREN fseen . FormalOpt RPAREN stmt
    (24) FormalOpt -> . Type ID
    (25) FormalOpt -> . empty
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . ID
    (17) Type -> . VOID
    (4) empty -> .

    INT             shift and go to state 11
    BOOL            shift and go to state 12
    ID              shift and go to state 8
    VOID            shift and go to state 1
    RPAREN          reduce using rule 4 (empty -> .)

    FormalOpt                      shift and go to state 68
    empty                          shift and go to state 70
    Type                           shift and go to state 69

state 30

    (23) fseen -> empty .

    INT             reduce using rule 23 (fseen -> empty .)
    BOOL            reduce using rule 23 (fseen -> empty .)
    ID              reduce using rule 23 (fseen -> empty .)
    VOID            reduce using rule 23 (fseen -> empty .)
    RPAREN          reduce using rule 23 (fseen -> empty .)


state 31

    (41) ReturnOpt -> RETURN . AE
    (42) ReturnOpt -> RETURN . VOID
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    VOID            shift and go to state 71
    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 74
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 32

    (55) doWhile -> DO . matchedstmt WHILE AE SCOLON
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    IF              shift and go to state 82
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    for                            shift and go to state 42
    FunctionCall                   shift and go to state 47
    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    doWhile                        shift and go to state 35
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    SE                             shift and go to state 66
    Print                          shift and go to state 38
    matchedstmt                    shift and go to state 81
    ArrayAccess                    shift and go to state 55
    ReturnOpt                      shift and go to state 56
    Block                          shift and go to state 58

state 33

    (69) Primary -> NUMBER .

    DOT             reduce using rule 69 (Primary -> NUMBER .)
    LBRACKET        reduce using rule 69 (Primary -> NUMBER .)
    PLUS            reduce using rule 69 (Primary -> NUMBER .)
    MINUS           reduce using rule 69 (Primary -> NUMBER .)
    MULT            reduce using rule 69 (Primary -> NUMBER .)
    DIVIDE          reduce using rule 69 (Primary -> NUMBER .)
    MOD             reduce using rule 69 (Primary -> NUMBER .)
    GREATERTHAN     reduce using rule 69 (Primary -> NUMBER .)
    GREATEROREQUAL  reduce using rule 69 (Primary -> NUMBER .)
    LESSTHAN        reduce using rule 69 (Primary -> NUMBER .)
    LESSOREQUAL     reduce using rule 69 (Primary -> NUMBER .)
    ISEQUAL         reduce using rule 69 (Primary -> NUMBER .)
    NOTEQUAL        reduce using rule 69 (Primary -> NUMBER .)
    AND             reduce using rule 69 (Primary -> NUMBER .)
    OR              reduce using rule 69 (Primary -> NUMBER .)
    SCOLON          reduce using rule 69 (Primary -> NUMBER .)
    DO              reduce using rule 69 (Primary -> NUMBER .)
    RPAREN          reduce using rule 69 (Primary -> NUMBER .)
    THEN            reduce using rule 69 (Primary -> NUMBER .)
    RBRACKET        reduce using rule 69 (Primary -> NUMBER .)


state 34

    (50) FieldAccess -> Primary . DOT ID
    (88) ArrayAccess -> Primary . LBRACKET AE RBRACKET

    DOT             shift and go to state 84
    LBRACKET        shift and go to state 83


state 35

    (38) matchedstmt -> doWhile .

    IF              reduce using rule 38 (matchedstmt -> doWhile .)
    INCREMENT       reduce using rule 38 (matchedstmt -> doWhile .)
    DECREMENT       reduce using rule 38 (matchedstmt -> doWhile .)
    PRINT           reduce using rule 38 (matchedstmt -> doWhile .)
    WHILE           reduce using rule 38 (matchedstmt -> doWhile .)
    LBRACE          reduce using rule 38 (matchedstmt -> doWhile .)
    DO              reduce using rule 38 (matchedstmt -> doWhile .)
    FOR             reduce using rule 38 (matchedstmt -> doWhile .)
    RETURN          reduce using rule 38 (matchedstmt -> doWhile .)
    ID              reduce using rule 38 (matchedstmt -> doWhile .)
    INPUT           reduce using rule 38 (matchedstmt -> doWhile .)
    TRUE            reduce using rule 38 (matchedstmt -> doWhile .)
    FALSE           reduce using rule 38 (matchedstmt -> doWhile .)
    LPAREN          reduce using rule 38 (matchedstmt -> doWhile .)
    NUMBER          reduce using rule 38 (matchedstmt -> doWhile .)
    NEW             reduce using rule 38 (matchedstmt -> doWhile .)
    RBRACE          reduce using rule 38 (matchedstmt -> doWhile .)
    CLASS           reduce using rule 38 (matchedstmt -> doWhile .)
    INT             reduce using rule 38 (matchedstmt -> doWhile .)
    BOOL            reduce using rule 38 (matchedstmt -> doWhile .)
    VOID            reduce using rule 38 (matchedstmt -> doWhile .)
    $end            reduce using rule 38 (matchedstmt -> doWhile .)
    ELSE            reduce using rule 38 (matchedstmt -> doWhile .)


state 36

    (54) While -> WHILE . AE DO matchedstmt
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 85
    FunctionCall                   shift and go to state 47
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 37

    (65) Primary -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 86


state 38

    (35) matchedstmt -> Print .

    IF              reduce using rule 35 (matchedstmt -> Print .)
    INCREMENT       reduce using rule 35 (matchedstmt -> Print .)
    DECREMENT       reduce using rule 35 (matchedstmt -> Print .)
    PRINT           reduce using rule 35 (matchedstmt -> Print .)
    WHILE           reduce using rule 35 (matchedstmt -> Print .)
    LBRACE          reduce using rule 35 (matchedstmt -> Print .)
    DO              reduce using rule 35 (matchedstmt -> Print .)
    FOR             reduce using rule 35 (matchedstmt -> Print .)
    RETURN          reduce using rule 35 (matchedstmt -> Print .)
    ID              reduce using rule 35 (matchedstmt -> Print .)
    INPUT           reduce using rule 35 (matchedstmt -> Print .)
    TRUE            reduce using rule 35 (matchedstmt -> Print .)
    FALSE           reduce using rule 35 (matchedstmt -> Print .)
    LPAREN          reduce using rule 35 (matchedstmt -> Print .)
    NUMBER          reduce using rule 35 (matchedstmt -> Print .)
    NEW             reduce using rule 35 (matchedstmt -> Print .)
    RBRACE          reduce using rule 35 (matchedstmt -> Print .)
    CLASS           reduce using rule 35 (matchedstmt -> Print .)
    INT             reduce using rule 35 (matchedstmt -> Print .)
    BOOL            reduce using rule 35 (matchedstmt -> Print .)
    VOID            reduce using rule 35 (matchedstmt -> Print .)
    $end            reduce using rule 35 (matchedstmt -> Print .)
    ELSE            reduce using rule 35 (matchedstmt -> Print .)


state 39

    (33) stmt -> openstmt .

    IF              reduce using rule 33 (stmt -> openstmt .)
    INCREMENT       reduce using rule 33 (stmt -> openstmt .)
    DECREMENT       reduce using rule 33 (stmt -> openstmt .)
    PRINT           reduce using rule 33 (stmt -> openstmt .)
    WHILE           reduce using rule 33 (stmt -> openstmt .)
    LBRACE          reduce using rule 33 (stmt -> openstmt .)
    DO              reduce using rule 33 (stmt -> openstmt .)
    FOR             reduce using rule 33 (stmt -> openstmt .)
    RETURN          reduce using rule 33 (stmt -> openstmt .)
    ID              reduce using rule 33 (stmt -> openstmt .)
    INPUT           reduce using rule 33 (stmt -> openstmt .)
    TRUE            reduce using rule 33 (stmt -> openstmt .)
    FALSE           reduce using rule 33 (stmt -> openstmt .)
    LPAREN          reduce using rule 33 (stmt -> openstmt .)
    NUMBER          reduce using rule 33 (stmt -> openstmt .)
    NEW             reduce using rule 33 (stmt -> openstmt .)
    RBRACE          reduce using rule 33 (stmt -> openstmt .)
    CLASS           reduce using rule 33 (stmt -> openstmt .)
    INT             reduce using rule 33 (stmt -> openstmt .)
    BOOL            reduce using rule 33 (stmt -> openstmt .)
    VOID            reduce using rule 33 (stmt -> openstmt .)
    $end            reduce using rule 33 (stmt -> openstmt .)


state 40

    (11) VarDecl -> Type . VarList SCOLON
    (18) VarList -> . Var COMMA VarList
    (19) VarList -> . Var
    (20) Var -> . ID DimStar

    ID              shift and go to state 27

    VarList                        shift and go to state 14
    Var                            shift and go to state 15

state 41

    (56) for -> FOR . LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt

    LPAREN          shift and go to state 87


state 42

    (39) matchedstmt -> for .

    IF              reduce using rule 39 (matchedstmt -> for .)
    INCREMENT       reduce using rule 39 (matchedstmt -> for .)
    DECREMENT       reduce using rule 39 (matchedstmt -> for .)
    PRINT           reduce using rule 39 (matchedstmt -> for .)
    WHILE           reduce using rule 39 (matchedstmt -> for .)
    LBRACE          reduce using rule 39 (matchedstmt -> for .)
    DO              reduce using rule 39 (matchedstmt -> for .)
    FOR             reduce using rule 39 (matchedstmt -> for .)
    RETURN          reduce using rule 39 (matchedstmt -> for .)
    ID              reduce using rule 39 (matchedstmt -> for .)
    INPUT           reduce using rule 39 (matchedstmt -> for .)
    TRUE            reduce using rule 39 (matchedstmt -> for .)
    FALSE           reduce using rule 39 (matchedstmt -> for .)
    LPAREN          reduce using rule 39 (matchedstmt -> for .)
    NUMBER          reduce using rule 39 (matchedstmt -> for .)
    NEW             reduce using rule 39 (matchedstmt -> for .)
    RBRACE          reduce using rule 39 (matchedstmt -> for .)
    CLASS           reduce using rule 39 (matchedstmt -> for .)
    INT             reduce using rule 39 (matchedstmt -> for .)
    BOOL            reduce using rule 39 (matchedstmt -> for .)
    VOID            reduce using rule 39 (matchedstmt -> for .)
    $end            reduce using rule 39 (matchedstmt -> for .)
    ELSE            reduce using rule 39 (matchedstmt -> for .)


state 43

    (66) Primary -> TRUE .

    DOT             reduce using rule 66 (Primary -> TRUE .)
    LBRACKET        reduce using rule 66 (Primary -> TRUE .)
    PLUS            reduce using rule 66 (Primary -> TRUE .)
    MINUS           reduce using rule 66 (Primary -> TRUE .)
    MULT            reduce using rule 66 (Primary -> TRUE .)
    DIVIDE          reduce using rule 66 (Primary -> TRUE .)
    MOD             reduce using rule 66 (Primary -> TRUE .)
    GREATERTHAN     reduce using rule 66 (Primary -> TRUE .)
    GREATEROREQUAL  reduce using rule 66 (Primary -> TRUE .)
    LESSTHAN        reduce using rule 66 (Primary -> TRUE .)
    LESSOREQUAL     reduce using rule 66 (Primary -> TRUE .)
    ISEQUAL         reduce using rule 66 (Primary -> TRUE .)
    NOTEQUAL        reduce using rule 66 (Primary -> TRUE .)
    AND             reduce using rule 66 (Primary -> TRUE .)
    OR              reduce using rule 66 (Primary -> TRUE .)
    SCOLON          reduce using rule 66 (Primary -> TRUE .)
    DO              reduce using rule 66 (Primary -> TRUE .)
    RPAREN          reduce using rule 66 (Primary -> TRUE .)
    THEN            reduce using rule 66 (Primary -> TRUE .)
    RBRACKET        reduce using rule 66 (Primary -> TRUE .)


state 44

    (86) Primary -> NEW . ID LPAREN RPAREN

    ID              shift and go to state 88


state 45

    (51) SE -> INCREMENT . LHS
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    LHS                            shift and go to state 89
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 55

state 46

    (53) Print -> PRINT . LPAREN AE RPAREN SCOLON

    LPAREN          shift and go to state 90


state 47

    (64) Primary -> FunctionCall .

    DOT             reduce using rule 64 (Primary -> FunctionCall .)
    LBRACKET        reduce using rule 64 (Primary -> FunctionCall .)
    PLUS            reduce using rule 64 (Primary -> FunctionCall .)
    MINUS           reduce using rule 64 (Primary -> FunctionCall .)
    MULT            reduce using rule 64 (Primary -> FunctionCall .)
    DIVIDE          reduce using rule 64 (Primary -> FunctionCall .)
    MOD             reduce using rule 64 (Primary -> FunctionCall .)
    GREATERTHAN     reduce using rule 64 (Primary -> FunctionCall .)
    GREATEROREQUAL  reduce using rule 64 (Primary -> FunctionCall .)
    LESSTHAN        reduce using rule 64 (Primary -> FunctionCall .)
    LESSOREQUAL     reduce using rule 64 (Primary -> FunctionCall .)
    ISEQUAL         reduce using rule 64 (Primary -> FunctionCall .)
    NOTEQUAL        reduce using rule 64 (Primary -> FunctionCall .)
    AND             reduce using rule 64 (Primary -> FunctionCall .)
    OR              reduce using rule 64 (Primary -> FunctionCall .)
    SCOLON          reduce using rule 64 (Primary -> FunctionCall .)
    DO              reduce using rule 64 (Primary -> FunctionCall .)
    RPAREN          reduce using rule 64 (Primary -> FunctionCall .)
    THEN            reduce using rule 64 (Primary -> FunctionCall .)
    RBRACKET        reduce using rule 64 (Primary -> FunctionCall .)


state 48

    (13) stmtSeq -> empty .

    RBRACE          reduce using rule 13 (stmtSeq -> empty .)


state 49

    (29) ClassDecl -> CLASS ID LBRACE Extension . RBRACE

    RBRACE          shift and go to state 91


state 50

    (12) stmtSeq -> stmt . stmtSeq
    (12) stmtSeq -> . stmt stmtSeq
    (13) stmtSeq -> . empty
    (32) stmt -> . matchedstmt
    (33) stmt -> . openstmt
    (4) empty -> .
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (43) openstmt -> . IF AE THEN stmt
    (44) openstmt -> . IF AE THEN matchedstmt ELSE openstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    RBRACE          reduce using rule 4 (empty -> .)
    IF              shift and go to state 59
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    doWhile                        shift and go to state 35
    Print                          shift and go to state 38
    openstmt                       shift and go to state 39
    for                            shift and go to state 42
    empty                          shift and go to state 48
    stmt                           shift and go to state 50
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    matchedstmt                    shift and go to state 54
    ArrayAccess                    shift and go to state 55
    ReturnOpt                      shift and go to state 56
    Block                          shift and go to state 58
    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    stmtSeq                        shift and go to state 92
    FunctionCall                   shift and go to state 47
    SE                             shift and go to state 66

state 51

    (36) matchedstmt -> While .

    IF              reduce using rule 36 (matchedstmt -> While .)
    INCREMENT       reduce using rule 36 (matchedstmt -> While .)
    DECREMENT       reduce using rule 36 (matchedstmt -> While .)
    PRINT           reduce using rule 36 (matchedstmt -> While .)
    WHILE           reduce using rule 36 (matchedstmt -> While .)
    LBRACE          reduce using rule 36 (matchedstmt -> While .)
    DO              reduce using rule 36 (matchedstmt -> While .)
    FOR             reduce using rule 36 (matchedstmt -> While .)
    RETURN          reduce using rule 36 (matchedstmt -> While .)
    ID              reduce using rule 36 (matchedstmt -> While .)
    INPUT           reduce using rule 36 (matchedstmt -> While .)
    TRUE            reduce using rule 36 (matchedstmt -> While .)
    FALSE           reduce using rule 36 (matchedstmt -> While .)
    LPAREN          reduce using rule 36 (matchedstmt -> While .)
    NUMBER          reduce using rule 36 (matchedstmt -> While .)
    NEW             reduce using rule 36 (matchedstmt -> While .)
    RBRACE          reduce using rule 36 (matchedstmt -> While .)
    CLASS           reduce using rule 36 (matchedstmt -> While .)
    INT             reduce using rule 36 (matchedstmt -> While .)
    BOOL            reduce using rule 36 (matchedstmt -> While .)
    VOID            reduce using rule 36 (matchedstmt -> While .)
    $end            reduce using rule 36 (matchedstmt -> While .)
    ELSE            reduce using rule 36 (matchedstmt -> While .)


state 52

    (46) SE -> LHS . EQUALS AE

    EQUALS          shift and go to state 93


state 53

    (68) Primary -> LPAREN . AE RPAREN
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 94
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 54

    (32) stmt -> matchedstmt .

    IF              reduce using rule 32 (stmt -> matchedstmt .)
    INCREMENT       reduce using rule 32 (stmt -> matchedstmt .)
    DECREMENT       reduce using rule 32 (stmt -> matchedstmt .)
    PRINT           reduce using rule 32 (stmt -> matchedstmt .)
    WHILE           reduce using rule 32 (stmt -> matchedstmt .)
    LBRACE          reduce using rule 32 (stmt -> matchedstmt .)
    DO              reduce using rule 32 (stmt -> matchedstmt .)
    FOR             reduce using rule 32 (stmt -> matchedstmt .)
    RETURN          reduce using rule 32 (stmt -> matchedstmt .)
    ID              reduce using rule 32 (stmt -> matchedstmt .)
    INPUT           reduce using rule 32 (stmt -> matchedstmt .)
    TRUE            reduce using rule 32 (stmt -> matchedstmt .)
    FALSE           reduce using rule 32 (stmt -> matchedstmt .)
    LPAREN          reduce using rule 32 (stmt -> matchedstmt .)
    NUMBER          reduce using rule 32 (stmt -> matchedstmt .)
    NEW             reduce using rule 32 (stmt -> matchedstmt .)
    RBRACE          reduce using rule 32 (stmt -> matchedstmt .)
    CLASS           reduce using rule 32 (stmt -> matchedstmt .)
    INT             reduce using rule 32 (stmt -> matchedstmt .)
    BOOL            reduce using rule 32 (stmt -> matchedstmt .)
    VOID            reduce using rule 32 (stmt -> matchedstmt .)
    $end            reduce using rule 32 (stmt -> matchedstmt .)


state 55

    (48) LHS -> ArrayAccess .
    (85) Primary -> ArrayAccess .

    EQUALS          reduce using rule 48 (LHS -> ArrayAccess .)
    SCOLON          reduce using rule 48 (LHS -> ArrayAccess .)
    PLUS            reduce using rule 48 (LHS -> ArrayAccess .)
    MINUS           reduce using rule 48 (LHS -> ArrayAccess .)
    MULT            reduce using rule 48 (LHS -> ArrayAccess .)
    DIVIDE          reduce using rule 48 (LHS -> ArrayAccess .)
    MOD             reduce using rule 48 (LHS -> ArrayAccess .)
    GREATERTHAN     reduce using rule 48 (LHS -> ArrayAccess .)
    GREATEROREQUAL  reduce using rule 48 (LHS -> ArrayAccess .)
    LESSTHAN        reduce using rule 48 (LHS -> ArrayAccess .)
    LESSOREQUAL     reduce using rule 48 (LHS -> ArrayAccess .)
    ISEQUAL         reduce using rule 48 (LHS -> ArrayAccess .)
    NOTEQUAL        reduce using rule 48 (LHS -> ArrayAccess .)
    AND             reduce using rule 48 (LHS -> ArrayAccess .)
    OR              reduce using rule 48 (LHS -> ArrayAccess .)
    DO              reduce using rule 48 (LHS -> ArrayAccess .)
    RPAREN          reduce using rule 48 (LHS -> ArrayAccess .)
    THEN            reduce using rule 48 (LHS -> ArrayAccess .)
    RBRACKET        reduce using rule 48 (LHS -> ArrayAccess .)
    DOT             reduce using rule 85 (Primary -> ArrayAccess .)
    LBRACKET        reduce using rule 85 (Primary -> ArrayAccess .)


state 56

    (40) matchedstmt -> ReturnOpt . SCOLON

    SCOLON          shift and go to state 95


state 57

    (16) Type -> ID .
    (49) FieldAccess -> ID .
    (26) FunctionCall -> ID . LPAREN Args RPAREN

    ID              reduce using rule 16 (Type -> ID .)
    EQUALS          reduce using rule 49 (FieldAccess -> ID .)
    DOT             reduce using rule 49 (FieldAccess -> ID .)
    LBRACKET        reduce using rule 49 (FieldAccess -> ID .)
    LPAREN          shift and go to state 96


state 58

    (37) matchedstmt -> Block .

    IF              reduce using rule 37 (matchedstmt -> Block .)
    INCREMENT       reduce using rule 37 (matchedstmt -> Block .)
    DECREMENT       reduce using rule 37 (matchedstmt -> Block .)
    PRINT           reduce using rule 37 (matchedstmt -> Block .)
    WHILE           reduce using rule 37 (matchedstmt -> Block .)
    LBRACE          reduce using rule 37 (matchedstmt -> Block .)
    DO              reduce using rule 37 (matchedstmt -> Block .)
    FOR             reduce using rule 37 (matchedstmt -> Block .)
    RETURN          reduce using rule 37 (matchedstmt -> Block .)
    ID              reduce using rule 37 (matchedstmt -> Block .)
    INPUT           reduce using rule 37 (matchedstmt -> Block .)
    TRUE            reduce using rule 37 (matchedstmt -> Block .)
    FALSE           reduce using rule 37 (matchedstmt -> Block .)
    LPAREN          reduce using rule 37 (matchedstmt -> Block .)
    NUMBER          reduce using rule 37 (matchedstmt -> Block .)
    NEW             reduce using rule 37 (matchedstmt -> Block .)
    RBRACE          reduce using rule 37 (matchedstmt -> Block .)
    CLASS           reduce using rule 37 (matchedstmt -> Block .)
    INT             reduce using rule 37 (matchedstmt -> Block .)
    BOOL            reduce using rule 37 (matchedstmt -> Block .)
    VOID            reduce using rule 37 (matchedstmt -> Block .)
    $end            reduce using rule 37 (matchedstmt -> Block .)
    ELSE            reduce using rule 37 (matchedstmt -> Block .)


state 59

    (45) matchedstmt -> IF . AE THEN matchedstmt ELSE matchedstmt
    (43) openstmt -> IF . AE THEN stmt
    (44) openstmt -> IF . AE THEN matchedstmt ELSE openstmt
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 97
    FunctionCall                   shift and go to state 47
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 60

    (90) Block -> LBRACE . seen Extension RBRACE
    (91) seen -> .

    INT             reduce using rule 91 (seen -> .)
    BOOL            reduce using rule 91 (seen -> .)
    ID              reduce using rule 91 (seen -> .)
    VOID            reduce using rule 91 (seen -> .)
    IF              reduce using rule 91 (seen -> .)
    INCREMENT       reduce using rule 91 (seen -> .)
    DECREMENT       reduce using rule 91 (seen -> .)
    PRINT           reduce using rule 91 (seen -> .)
    WHILE           reduce using rule 91 (seen -> .)
    LBRACE          reduce using rule 91 (seen -> .)
    DO              reduce using rule 91 (seen -> .)
    FOR             reduce using rule 91 (seen -> .)
    RETURN          reduce using rule 91 (seen -> .)
    INPUT           reduce using rule 91 (seen -> .)
    TRUE            reduce using rule 91 (seen -> .)
    FALSE           reduce using rule 91 (seen -> .)
    LPAREN          reduce using rule 91 (seen -> .)
    NUMBER          reduce using rule 91 (seen -> .)
    NEW             reduce using rule 91 (seen -> .)
    RBRACE          reduce using rule 91 (seen -> .)

    seen                           shift and go to state 98

state 61

    (67) Primary -> FALSE .

    DOT             reduce using rule 67 (Primary -> FALSE .)
    LBRACKET        reduce using rule 67 (Primary -> FALSE .)
    PLUS            reduce using rule 67 (Primary -> FALSE .)
    MINUS           reduce using rule 67 (Primary -> FALSE .)
    MULT            reduce using rule 67 (Primary -> FALSE .)
    DIVIDE          reduce using rule 67 (Primary -> FALSE .)
    MOD             reduce using rule 67 (Primary -> FALSE .)
    GREATERTHAN     reduce using rule 67 (Primary -> FALSE .)
    GREATEROREQUAL  reduce using rule 67 (Primary -> FALSE .)
    LESSTHAN        reduce using rule 67 (Primary -> FALSE .)
    LESSOREQUAL     reduce using rule 67 (Primary -> FALSE .)
    ISEQUAL         reduce using rule 67 (Primary -> FALSE .)
    NOTEQUAL        reduce using rule 67 (Primary -> FALSE .)
    AND             reduce using rule 67 (Primary -> FALSE .)
    OR              reduce using rule 67 (Primary -> FALSE .)
    SCOLON          reduce using rule 67 (Primary -> FALSE .)
    DO              reduce using rule 67 (Primary -> FALSE .)
    RPAREN          reduce using rule 67 (Primary -> FALSE .)
    THEN            reduce using rule 67 (Primary -> FALSE .)
    RBRACKET        reduce using rule 67 (Primary -> FALSE .)


state 62

    (47) LHS -> FieldAccess .
    (63) Primary -> FieldAccess .

    EQUALS          reduce using rule 47 (LHS -> FieldAccess .)
    SCOLON          reduce using rule 47 (LHS -> FieldAccess .)
    PLUS            reduce using rule 47 (LHS -> FieldAccess .)
    MINUS           reduce using rule 47 (LHS -> FieldAccess .)
    MULT            reduce using rule 47 (LHS -> FieldAccess .)
    DIVIDE          reduce using rule 47 (LHS -> FieldAccess .)
    MOD             reduce using rule 47 (LHS -> FieldAccess .)
    GREATERTHAN     reduce using rule 47 (LHS -> FieldAccess .)
    GREATEROREQUAL  reduce using rule 47 (LHS -> FieldAccess .)
    LESSTHAN        reduce using rule 47 (LHS -> FieldAccess .)
    LESSOREQUAL     reduce using rule 47 (LHS -> FieldAccess .)
    ISEQUAL         reduce using rule 47 (LHS -> FieldAccess .)
    NOTEQUAL        reduce using rule 47 (LHS -> FieldAccess .)
    AND             reduce using rule 47 (LHS -> FieldAccess .)
    OR              reduce using rule 47 (LHS -> FieldAccess .)
    DO              reduce using rule 47 (LHS -> FieldAccess .)
    RPAREN          reduce using rule 47 (LHS -> FieldAccess .)
    THEN            reduce using rule 47 (LHS -> FieldAccess .)
    RBRACKET        reduce using rule 47 (LHS -> FieldAccess .)
    DOT             reduce using rule 63 (Primary -> FieldAccess .)
    LBRACKET        reduce using rule 63 (Primary -> FieldAccess .)


state 63

    (6) Extension -> VarDecl .
    (7) Extension -> VarDecl . Extension
    (6) Extension -> . VarDecl
    (7) Extension -> . VarDecl Extension
    (8) Extension -> . stmtSeq
    (11) VarDecl -> . Type VarList SCOLON
    (12) stmtSeq -> . stmt stmtSeq
    (13) stmtSeq -> . empty
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . ID
    (17) Type -> . VOID
    (32) stmt -> . matchedstmt
    (33) stmt -> . openstmt
    (4) empty -> .
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (43) openstmt -> . IF AE THEN stmt
    (44) openstmt -> . IF AE THEN matchedstmt ELSE openstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

  ! reduce/reduce conflict for RBRACE resolved using rule 4 (empty -> .)
    INT             shift and go to state 11
    BOOL            shift and go to state 12
    ID              shift and go to state 57
    VOID            shift and go to state 1
    RBRACE          reduce using rule 4 (empty -> .)
    IF              shift and go to state 59
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

  ! RBRACE          [ reduce using rule 6 (Extension -> VarDecl .) ]

    doWhile                        shift and go to state 35
    Print                          shift and go to state 38
    openstmt                       shift and go to state 39
    Type                           shift and go to state 40
    for                            shift and go to state 42
    empty                          shift and go to state 48
    Extension                      shift and go to state 99
    stmt                           shift and go to state 50
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    matchedstmt                    shift and go to state 54
    ArrayAccess                    shift and go to state 55
    ReturnOpt                      shift and go to state 56
    Block                          shift and go to state 58
    FieldAccess                    shift and go to state 62
    VarDecl                        shift and go to state 63
    Primary                        shift and go to state 34
    stmtSeq                        shift and go to state 64
    FunctionCall                   shift and go to state 47
    SE                             shift and go to state 66

state 64

    (8) Extension -> stmtSeq .

    RBRACE          reduce using rule 8 (Extension -> stmtSeq .)


state 65

    (52) SE -> DECREMENT . LHS
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    LHS                            shift and go to state 100
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 55

state 66

    (34) matchedstmt -> SE . SCOLON

    SCOLON          shift and go to state 101


state 67

    (31) DimStar -> LBRACKET RBRACKET DimStar .

    COMMA           reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    SCOLON          reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    PLUS            reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    MINUS           reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    MULT            reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    DIVIDE          reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    MOD             reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    GREATERTHAN     reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    GREATEROREQUAL  reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    LESSTHAN        reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    LESSOREQUAL     reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    ISEQUAL         reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    NOTEQUAL        reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    AND             reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    OR              reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    DO              reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    RPAREN          reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    THEN            reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)
    RBRACKET        reduce using rule 31 (DimStar -> LBRACKET RBRACKET DimStar .)


state 68

    (22) FunDecl -> Type ID LPAREN fseen FormalOpt . RPAREN stmt

    RPAREN          shift and go to state 102


state 69

    (24) FormalOpt -> Type . ID

    ID              shift and go to state 103


state 70

    (25) FormalOpt -> empty .

    RPAREN          reduce using rule 25 (FormalOpt -> empty .)


state 71

    (42) ReturnOpt -> RETURN VOID .

    SCOLON          reduce using rule 42 (ReturnOpt -> RETURN VOID .)


state 72

    (87) AE -> NEW . Type DimExpr DimStar
    (86) Primary -> NEW . ID LPAREN RPAREN
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . ID
    (17) Type -> . VOID

    ID              shift and go to state 105
    INT             shift and go to state 11
    BOOL            shift and go to state 12
    VOID            shift and go to state 1

    Type                           shift and go to state 104

state 73

    (75) AE -> MINUS . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 106
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 74

    (41) ReturnOpt -> RETURN AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    SCOLON          reduce using rule 41 (ReturnOpt -> RETURN AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 75

    (85) Primary -> ArrayAccess .
    (48) LHS -> ArrayAccess .

    DOT             reduce using rule 85 (Primary -> ArrayAccess .)
    LBRACKET        reduce using rule 85 (Primary -> ArrayAccess .)
    PLUS            reduce using rule 85 (Primary -> ArrayAccess .)
    MINUS           reduce using rule 85 (Primary -> ArrayAccess .)
    MULT            reduce using rule 85 (Primary -> ArrayAccess .)
    DIVIDE          reduce using rule 85 (Primary -> ArrayAccess .)
    MOD             reduce using rule 85 (Primary -> ArrayAccess .)
    GREATERTHAN     reduce using rule 85 (Primary -> ArrayAccess .)
    GREATEROREQUAL  reduce using rule 85 (Primary -> ArrayAccess .)
    LESSTHAN        reduce using rule 85 (Primary -> ArrayAccess .)
    LESSOREQUAL     reduce using rule 85 (Primary -> ArrayAccess .)
    ISEQUAL         reduce using rule 85 (Primary -> ArrayAccess .)
    NOTEQUAL        reduce using rule 85 (Primary -> ArrayAccess .)
    AND             reduce using rule 85 (Primary -> ArrayAccess .)
    OR              reduce using rule 85 (Primary -> ArrayAccess .)
    SCOLON          reduce using rule 85 (Primary -> ArrayAccess .)
    DO              reduce using rule 85 (Primary -> ArrayAccess .)
    RPAREN          reduce using rule 85 (Primary -> ArrayAccess .)
    THEN            reduce using rule 85 (Primary -> ArrayAccess .)
    RBRACKET        reduce using rule 85 (Primary -> ArrayAccess .)
    EQUALS          reduce using rule 48 (LHS -> ArrayAccess .)


state 76

    (49) FieldAccess -> ID .
    (26) FunctionCall -> ID . LPAREN Args RPAREN

    DOT             reduce using rule 49 (FieldAccess -> ID .)
    LBRACKET        reduce using rule 49 (FieldAccess -> ID .)
    THEN            reduce using rule 49 (FieldAccess -> ID .)
    PLUS            reduce using rule 49 (FieldAccess -> ID .)
    MINUS           reduce using rule 49 (FieldAccess -> ID .)
    MULT            reduce using rule 49 (FieldAccess -> ID .)
    DIVIDE          reduce using rule 49 (FieldAccess -> ID .)
    MOD             reduce using rule 49 (FieldAccess -> ID .)
    GREATERTHAN     reduce using rule 49 (FieldAccess -> ID .)
    GREATEROREQUAL  reduce using rule 49 (FieldAccess -> ID .)
    LESSTHAN        reduce using rule 49 (FieldAccess -> ID .)
    LESSOREQUAL     reduce using rule 49 (FieldAccess -> ID .)
    ISEQUAL         reduce using rule 49 (FieldAccess -> ID .)
    NOTEQUAL        reduce using rule 49 (FieldAccess -> ID .)
    AND             reduce using rule 49 (FieldAccess -> ID .)
    OR              reduce using rule 49 (FieldAccess -> ID .)
    EQUALS          reduce using rule 49 (FieldAccess -> ID .)
    SCOLON          reduce using rule 49 (FieldAccess -> ID .)
    DO              reduce using rule 49 (FieldAccess -> ID .)
    RPAREN          reduce using rule 49 (FieldAccess -> ID .)
    RBRACKET        reduce using rule 49 (FieldAccess -> ID .)
    LPAREN          shift and go to state 96


state 77

    (63) Primary -> FieldAccess .
    (47) LHS -> FieldAccess .

    DOT             reduce using rule 63 (Primary -> FieldAccess .)
    LBRACKET        reduce using rule 63 (Primary -> FieldAccess .)
    PLUS            reduce using rule 63 (Primary -> FieldAccess .)
    MINUS           reduce using rule 63 (Primary -> FieldAccess .)
    MULT            reduce using rule 63 (Primary -> FieldAccess .)
    DIVIDE          reduce using rule 63 (Primary -> FieldAccess .)
    MOD             reduce using rule 63 (Primary -> FieldAccess .)
    GREATERTHAN     reduce using rule 63 (Primary -> FieldAccess .)
    GREATEROREQUAL  reduce using rule 63 (Primary -> FieldAccess .)
    LESSTHAN        reduce using rule 63 (Primary -> FieldAccess .)
    LESSOREQUAL     reduce using rule 63 (Primary -> FieldAccess .)
    ISEQUAL         reduce using rule 63 (Primary -> FieldAccess .)
    NOTEQUAL        reduce using rule 63 (Primary -> FieldAccess .)
    AND             reduce using rule 63 (Primary -> FieldAccess .)
    OR              reduce using rule 63 (Primary -> FieldAccess .)
    SCOLON          reduce using rule 63 (Primary -> FieldAccess .)
    DO              reduce using rule 63 (Primary -> FieldAccess .)
    RPAREN          reduce using rule 63 (Primary -> FieldAccess .)
    THEN            reduce using rule 63 (Primary -> FieldAccess .)
    RBRACKET        reduce using rule 63 (Primary -> FieldAccess .)
    EQUALS          reduce using rule 47 (LHS -> FieldAccess .)


state 78

    (62) AE -> Primary .
    (50) FieldAccess -> Primary . DOT ID
    (88) ArrayAccess -> Primary . LBRACKET AE RBRACKET

    PLUS            reduce using rule 62 (AE -> Primary .)
    MINUS           reduce using rule 62 (AE -> Primary .)
    MULT            reduce using rule 62 (AE -> Primary .)
    DIVIDE          reduce using rule 62 (AE -> Primary .)
    MOD             reduce using rule 62 (AE -> Primary .)
    GREATERTHAN     reduce using rule 62 (AE -> Primary .)
    GREATEROREQUAL  reduce using rule 62 (AE -> Primary .)
    LESSTHAN        reduce using rule 62 (AE -> Primary .)
    LESSOREQUAL     reduce using rule 62 (AE -> Primary .)
    ISEQUAL         reduce using rule 62 (AE -> Primary .)
    NOTEQUAL        reduce using rule 62 (AE -> Primary .)
    AND             reduce using rule 62 (AE -> Primary .)
    OR              reduce using rule 62 (AE -> Primary .)
    SCOLON          reduce using rule 62 (AE -> Primary .)
    DO              reduce using rule 62 (AE -> Primary .)
    RPAREN          reduce using rule 62 (AE -> Primary .)
    THEN            reduce using rule 62 (AE -> Primary .)
    RBRACKET        reduce using rule 62 (AE -> Primary .)
    DOT             shift and go to state 84
    LBRACKET        shift and go to state 83


state 79

    (84) AE -> NOT . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 120
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 80

    (61) AE -> SE .

    PLUS            reduce using rule 61 (AE -> SE .)
    MINUS           reduce using rule 61 (AE -> SE .)
    MULT            reduce using rule 61 (AE -> SE .)
    DIVIDE          reduce using rule 61 (AE -> SE .)
    MOD             reduce using rule 61 (AE -> SE .)
    GREATERTHAN     reduce using rule 61 (AE -> SE .)
    GREATEROREQUAL  reduce using rule 61 (AE -> SE .)
    LESSTHAN        reduce using rule 61 (AE -> SE .)
    LESSOREQUAL     reduce using rule 61 (AE -> SE .)
    ISEQUAL         reduce using rule 61 (AE -> SE .)
    NOTEQUAL        reduce using rule 61 (AE -> SE .)
    AND             reduce using rule 61 (AE -> SE .)
    OR              reduce using rule 61 (AE -> SE .)
    SCOLON          reduce using rule 61 (AE -> SE .)
    DO              reduce using rule 61 (AE -> SE .)
    RPAREN          reduce using rule 61 (AE -> SE .)
    THEN            reduce using rule 61 (AE -> SE .)
    RBRACKET        reduce using rule 61 (AE -> SE .)


state 81

    (55) doWhile -> DO matchedstmt . WHILE AE SCOLON

    WHILE           shift and go to state 121


state 82

    (45) matchedstmt -> IF . AE THEN matchedstmt ELSE matchedstmt
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 122
    FunctionCall                   shift and go to state 47
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 83

    (88) ArrayAccess -> Primary LBRACKET . AE RBRACKET
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 123
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 84

    (50) FieldAccess -> Primary DOT . ID

    ID              shift and go to state 124


state 85

    (54) While -> WHILE AE . DO matchedstmt
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    DO              shift and go to state 125
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 86

    (65) Primary -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 126


state 87

    (56) for -> FOR LPAREN . SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (57) SEopt -> . SE
    (58) SEopt -> . empty
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (4) empty -> .
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    SCOLON          reduce using rule 4 (empty -> .)
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    FunctionCall                   shift and go to state 47
    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    SEopt                          shift and go to state 127
    LHS                            shift and go to state 52
    SE                             shift and go to state 129
    ArrayAccess                    shift and go to state 55
    empty                          shift and go to state 128

state 88

    (86) Primary -> NEW ID . LPAREN RPAREN

    LPAREN          shift and go to state 130


state 89

    (51) SE -> INCREMENT LHS .

    PLUS            reduce using rule 51 (SE -> INCREMENT LHS .)
    MINUS           reduce using rule 51 (SE -> INCREMENT LHS .)
    MULT            reduce using rule 51 (SE -> INCREMENT LHS .)
    DIVIDE          reduce using rule 51 (SE -> INCREMENT LHS .)
    MOD             reduce using rule 51 (SE -> INCREMENT LHS .)
    GREATERTHAN     reduce using rule 51 (SE -> INCREMENT LHS .)
    GREATEROREQUAL  reduce using rule 51 (SE -> INCREMENT LHS .)
    LESSTHAN        reduce using rule 51 (SE -> INCREMENT LHS .)
    LESSOREQUAL     reduce using rule 51 (SE -> INCREMENT LHS .)
    ISEQUAL         reduce using rule 51 (SE -> INCREMENT LHS .)
    NOTEQUAL        reduce using rule 51 (SE -> INCREMENT LHS .)
    AND             reduce using rule 51 (SE -> INCREMENT LHS .)
    OR              reduce using rule 51 (SE -> INCREMENT LHS .)
    SCOLON          reduce using rule 51 (SE -> INCREMENT LHS .)
    DO              reduce using rule 51 (SE -> INCREMENT LHS .)
    RPAREN          reduce using rule 51 (SE -> INCREMENT LHS .)
    THEN            reduce using rule 51 (SE -> INCREMENT LHS .)
    RBRACKET        reduce using rule 51 (SE -> INCREMENT LHS .)


state 90

    (53) Print -> PRINT LPAREN . AE RPAREN SCOLON
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 131
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 91

    (29) ClassDecl -> CLASS ID LBRACE Extension RBRACE .

    CLASS           reduce using rule 29 (ClassDecl -> CLASS ID LBRACE Extension RBRACE .)
    INT             reduce using rule 29 (ClassDecl -> CLASS ID LBRACE Extension RBRACE .)
    BOOL            reduce using rule 29 (ClassDecl -> CLASS ID LBRACE Extension RBRACE .)
    ID              reduce using rule 29 (ClassDecl -> CLASS ID LBRACE Extension RBRACE .)
    VOID            reduce using rule 29 (ClassDecl -> CLASS ID LBRACE Extension RBRACE .)
    $end            reduce using rule 29 (ClassDecl -> CLASS ID LBRACE Extension RBRACE .)


state 92

    (12) stmtSeq -> stmt stmtSeq .

    RBRACE          reduce using rule 12 (stmtSeq -> stmt stmtSeq .)


state 93

    (46) SE -> LHS EQUALS . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 132
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 94

    (68) Primary -> LPAREN AE . RPAREN
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    RPAREN          shift and go to state 133
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 95

    (40) matchedstmt -> ReturnOpt SCOLON .

    IF              reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    INCREMENT       reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    DECREMENT       reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    PRINT           reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    WHILE           reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    LBRACE          reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    DO              reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    FOR             reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    RETURN          reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    ID              reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    INPUT           reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    TRUE            reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    FALSE           reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    LPAREN          reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    NUMBER          reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    NEW             reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    RBRACE          reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    CLASS           reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    INT             reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    BOOL            reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    VOID            reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    $end            reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)
    ELSE            reduce using rule 40 (matchedstmt -> ReturnOpt SCOLON .)


state 96

    (26) FunctionCall -> ID LPAREN . Args RPAREN
    (27) Args -> . AE
    (28) Args -> . empty
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (4) empty -> .
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    RPAREN          reduce using rule 4 (empty -> .)
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 136
    Args                           shift and go to state 134
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    empty                          shift and go to state 135
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 97

    (45) matchedstmt -> IF AE . THEN matchedstmt ELSE matchedstmt
    (43) openstmt -> IF AE . THEN stmt
    (44) openstmt -> IF AE . THEN matchedstmt ELSE openstmt
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    THEN            shift and go to state 137
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 98

    (90) Block -> LBRACE seen . Extension RBRACE
    (6) Extension -> . VarDecl
    (7) Extension -> . VarDecl Extension
    (8) Extension -> . stmtSeq
    (11) VarDecl -> . Type VarList SCOLON
    (12) stmtSeq -> . stmt stmtSeq
    (13) stmtSeq -> . empty
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . ID
    (17) Type -> . VOID
    (32) stmt -> . matchedstmt
    (33) stmt -> . openstmt
    (4) empty -> .
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (43) openstmt -> . IF AE THEN stmt
    (44) openstmt -> . IF AE THEN matchedstmt ELSE openstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    INT             shift and go to state 11
    BOOL            shift and go to state 12
    ID              shift and go to state 57
    VOID            shift and go to state 1
    RBRACE          reduce using rule 4 (empty -> .)
    IF              shift and go to state 59
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    doWhile                        shift and go to state 35
    Print                          shift and go to state 38
    openstmt                       shift and go to state 39
    Type                           shift and go to state 40
    for                            shift and go to state 42
    empty                          shift and go to state 48
    Extension                      shift and go to state 138
    stmt                           shift and go to state 50
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    matchedstmt                    shift and go to state 54
    ArrayAccess                    shift and go to state 55
    ReturnOpt                      shift and go to state 56
    Block                          shift and go to state 58
    FieldAccess                    shift and go to state 62
    VarDecl                        shift and go to state 63
    Primary                        shift and go to state 34
    stmtSeq                        shift and go to state 64
    FunctionCall                   shift and go to state 47
    SE                             shift and go to state 66

state 99

    (7) Extension -> VarDecl Extension .

    RBRACE          reduce using rule 7 (Extension -> VarDecl Extension .)


state 100

    (52) SE -> DECREMENT LHS .

    PLUS            reduce using rule 52 (SE -> DECREMENT LHS .)
    MINUS           reduce using rule 52 (SE -> DECREMENT LHS .)
    MULT            reduce using rule 52 (SE -> DECREMENT LHS .)
    DIVIDE          reduce using rule 52 (SE -> DECREMENT LHS .)
    MOD             reduce using rule 52 (SE -> DECREMENT LHS .)
    GREATERTHAN     reduce using rule 52 (SE -> DECREMENT LHS .)
    GREATEROREQUAL  reduce using rule 52 (SE -> DECREMENT LHS .)
    LESSTHAN        reduce using rule 52 (SE -> DECREMENT LHS .)
    LESSOREQUAL     reduce using rule 52 (SE -> DECREMENT LHS .)
    ISEQUAL         reduce using rule 52 (SE -> DECREMENT LHS .)
    NOTEQUAL        reduce using rule 52 (SE -> DECREMENT LHS .)
    AND             reduce using rule 52 (SE -> DECREMENT LHS .)
    OR              reduce using rule 52 (SE -> DECREMENT LHS .)
    SCOLON          reduce using rule 52 (SE -> DECREMENT LHS .)
    DO              reduce using rule 52 (SE -> DECREMENT LHS .)
    RPAREN          reduce using rule 52 (SE -> DECREMENT LHS .)
    THEN            reduce using rule 52 (SE -> DECREMENT LHS .)
    RBRACKET        reduce using rule 52 (SE -> DECREMENT LHS .)


state 101

    (34) matchedstmt -> SE SCOLON .

    IF              reduce using rule 34 (matchedstmt -> SE SCOLON .)
    INCREMENT       reduce using rule 34 (matchedstmt -> SE SCOLON .)
    DECREMENT       reduce using rule 34 (matchedstmt -> SE SCOLON .)
    PRINT           reduce using rule 34 (matchedstmt -> SE SCOLON .)
    WHILE           reduce using rule 34 (matchedstmt -> SE SCOLON .)
    LBRACE          reduce using rule 34 (matchedstmt -> SE SCOLON .)
    DO              reduce using rule 34 (matchedstmt -> SE SCOLON .)
    FOR             reduce using rule 34 (matchedstmt -> SE SCOLON .)
    RETURN          reduce using rule 34 (matchedstmt -> SE SCOLON .)
    ID              reduce using rule 34 (matchedstmt -> SE SCOLON .)
    INPUT           reduce using rule 34 (matchedstmt -> SE SCOLON .)
    TRUE            reduce using rule 34 (matchedstmt -> SE SCOLON .)
    FALSE           reduce using rule 34 (matchedstmt -> SE SCOLON .)
    LPAREN          reduce using rule 34 (matchedstmt -> SE SCOLON .)
    NUMBER          reduce using rule 34 (matchedstmt -> SE SCOLON .)
    NEW             reduce using rule 34 (matchedstmt -> SE SCOLON .)
    RBRACE          reduce using rule 34 (matchedstmt -> SE SCOLON .)
    CLASS           reduce using rule 34 (matchedstmt -> SE SCOLON .)
    INT             reduce using rule 34 (matchedstmt -> SE SCOLON .)
    BOOL            reduce using rule 34 (matchedstmt -> SE SCOLON .)
    VOID            reduce using rule 34 (matchedstmt -> SE SCOLON .)
    $end            reduce using rule 34 (matchedstmt -> SE SCOLON .)
    ELSE            reduce using rule 34 (matchedstmt -> SE SCOLON .)


state 102

    (22) FunDecl -> Type ID LPAREN fseen FormalOpt RPAREN . stmt
    (32) stmt -> . matchedstmt
    (33) stmt -> . openstmt
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (43) openstmt -> . IF AE THEN stmt
    (44) openstmt -> . IF AE THEN matchedstmt ELSE openstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    IF              shift and go to state 59
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    doWhile                        shift and go to state 35
    Print                          shift and go to state 38
    openstmt                       shift and go to state 39
    for                            shift and go to state 42
    stmt                           shift and go to state 139
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    matchedstmt                    shift and go to state 54
    ArrayAccess                    shift and go to state 55
    ReturnOpt                      shift and go to state 56
    Block                          shift and go to state 58
    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    FunctionCall                   shift and go to state 47
    SE                             shift and go to state 66

state 103

    (24) FormalOpt -> Type ID .

    RPAREN          reduce using rule 24 (FormalOpt -> Type ID .)


state 104

    (87) AE -> NEW Type . DimExpr DimStar
    (89) DimExpr -> . LBRACKET AE RBRACKET

    LBRACKET        shift and go to state 140

    DimExpr                        shift and go to state 141

state 105

    (86) Primary -> NEW ID . LPAREN RPAREN
    (16) Type -> ID .

    LPAREN          shift and go to state 130
    LBRACKET        reduce using rule 16 (Type -> ID .)


state 106

    (75) AE -> MINUS AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    PLUS            reduce using rule 75 (AE -> MINUS AE .)
    MINUS           reduce using rule 75 (AE -> MINUS AE .)
    MULT            reduce using rule 75 (AE -> MINUS AE .)
    DIVIDE          reduce using rule 75 (AE -> MINUS AE .)
    MOD             reduce using rule 75 (AE -> MINUS AE .)
    GREATERTHAN     reduce using rule 75 (AE -> MINUS AE .)
    GREATEROREQUAL  reduce using rule 75 (AE -> MINUS AE .)
    LESSTHAN        reduce using rule 75 (AE -> MINUS AE .)
    LESSOREQUAL     reduce using rule 75 (AE -> MINUS AE .)
    ISEQUAL         reduce using rule 75 (AE -> MINUS AE .)
    NOTEQUAL        reduce using rule 75 (AE -> MINUS AE .)
    AND             reduce using rule 75 (AE -> MINUS AE .)
    OR              reduce using rule 75 (AE -> MINUS AE .)
    SCOLON          reduce using rule 75 (AE -> MINUS AE .)
    DO              reduce using rule 75 (AE -> MINUS AE .)
    RPAREN          reduce using rule 75 (AE -> MINUS AE .)
    THEN            reduce using rule 75 (AE -> MINUS AE .)
    RBRACKET        reduce using rule 75 (AE -> MINUS AE .)

  ! PLUS            [ shift and go to state 114 ]
  ! MINUS           [ shift and go to state 117 ]
  ! MULT            [ shift and go to state 118 ]
  ! DIVIDE          [ shift and go to state 110 ]
  ! MOD             [ shift and go to state 119 ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 107

    (82) AE -> AE AND . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 142
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 108

    (81) AE -> AE NOTEQUAL . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 143
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 109

    (79) AE -> AE LESSOREQUAL . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 144
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 110

    (73) AE -> AE DIVIDE . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 145
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 111

    (80) AE -> AE ISEQUAL . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 146
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 112

    (83) AE -> AE OR . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 147
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 113

    (78) AE -> AE LESSTHAN . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 148
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 114

    (70) AE -> AE PLUS . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 149
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 115

    (77) AE -> AE GREATEROREQUAL . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 150
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 116

    (76) AE -> AE GREATERTHAN . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 151
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 117

    (71) AE -> AE MINUS . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 152
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 118

    (72) AE -> AE MULT . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 153
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 119

    (74) AE -> AE MOD . AE
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 154
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 120

    (84) AE -> NOT AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    PLUS            reduce using rule 84 (AE -> NOT AE .)
    MINUS           reduce using rule 84 (AE -> NOT AE .)
    MULT            reduce using rule 84 (AE -> NOT AE .)
    DIVIDE          reduce using rule 84 (AE -> NOT AE .)
    MOD             reduce using rule 84 (AE -> NOT AE .)
    GREATERTHAN     reduce using rule 84 (AE -> NOT AE .)
    GREATEROREQUAL  reduce using rule 84 (AE -> NOT AE .)
    LESSTHAN        reduce using rule 84 (AE -> NOT AE .)
    LESSOREQUAL     reduce using rule 84 (AE -> NOT AE .)
    ISEQUAL         reduce using rule 84 (AE -> NOT AE .)
    NOTEQUAL        reduce using rule 84 (AE -> NOT AE .)
    AND             reduce using rule 84 (AE -> NOT AE .)
    OR              reduce using rule 84 (AE -> NOT AE .)
    SCOLON          reduce using rule 84 (AE -> NOT AE .)
    DO              reduce using rule 84 (AE -> NOT AE .)
    RPAREN          reduce using rule 84 (AE -> NOT AE .)
    THEN            reduce using rule 84 (AE -> NOT AE .)
    RBRACKET        reduce using rule 84 (AE -> NOT AE .)

  ! PLUS            [ shift and go to state 114 ]
  ! MINUS           [ shift and go to state 117 ]
  ! MULT            [ shift and go to state 118 ]
  ! DIVIDE          [ shift and go to state 110 ]
  ! MOD             [ shift and go to state 119 ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 121

    (55) doWhile -> DO matchedstmt WHILE . AE SCOLON
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 155
    FunctionCall                   shift and go to state 47
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 122

    (45) matchedstmt -> IF AE . THEN matchedstmt ELSE matchedstmt
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    THEN            shift and go to state 156
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 123

    (88) ArrayAccess -> Primary LBRACKET AE . RBRACKET
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    RBRACKET        shift and go to state 157
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 124

    (50) FieldAccess -> Primary DOT ID .

    DOT             reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    LBRACKET        reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    THEN            reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    PLUS            reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    MINUS           reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    MULT            reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    DIVIDE          reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    MOD             reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    GREATERTHAN     reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    GREATEROREQUAL  reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    LESSTHAN        reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    LESSOREQUAL     reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    ISEQUAL         reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    NOTEQUAL        reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    AND             reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    OR              reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    EQUALS          reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    SCOLON          reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    DO              reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    RPAREN          reduce using rule 50 (FieldAccess -> Primary DOT ID .)
    RBRACKET        reduce using rule 50 (FieldAccess -> Primary DOT ID .)


state 125

    (54) While -> WHILE AE DO . matchedstmt
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    IF              shift and go to state 82
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    for                            shift and go to state 42
    FunctionCall                   shift and go to state 47
    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    doWhile                        shift and go to state 35
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    SE                             shift and go to state 66
    Print                          shift and go to state 38
    matchedstmt                    shift and go to state 158
    ArrayAccess                    shift and go to state 55
    ReturnOpt                      shift and go to state 56
    Block                          shift and go to state 58

state 126

    (65) Primary -> INPUT LPAREN RPAREN .

    DOT             reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    LBRACKET        reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    PLUS            reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    MINUS           reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    MULT            reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    DIVIDE          reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    MOD             reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    GREATERTHAN     reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    GREATEROREQUAL  reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    LESSTHAN        reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    LESSOREQUAL     reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    ISEQUAL         reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    AND             reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    OR              reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    SCOLON          reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    DO              reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    THEN            reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)
    RBRACKET        reduce using rule 65 (Primary -> INPUT LPAREN RPAREN .)


state 127

    (56) for -> FOR LPAREN SEopt . SCOLON AEopt SCOLON SEopt RPAREN matchedstmt

    SCOLON          shift and go to state 159


state 128

    (58) SEopt -> empty .

    SCOLON          reduce using rule 58 (SEopt -> empty .)
    RPAREN          reduce using rule 58 (SEopt -> empty .)


state 129

    (57) SEopt -> SE .

    SCOLON          reduce using rule 57 (SEopt -> SE .)
    RPAREN          reduce using rule 57 (SEopt -> SE .)


state 130

    (86) Primary -> NEW ID LPAREN . RPAREN

    RPAREN          shift and go to state 160


state 131

    (53) Print -> PRINT LPAREN AE . RPAREN SCOLON
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    RPAREN          shift and go to state 161
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 132

    (46) SE -> LHS EQUALS AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATEROREQUAL resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for LESSOREQUAL resolved as shift
  ! shift/reduce conflict for ISEQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SCOLON          reduce using rule 46 (SE -> LHS EQUALS AE .)
    DO              reduce using rule 46 (SE -> LHS EQUALS AE .)
    RPAREN          reduce using rule 46 (SE -> LHS EQUALS AE .)
    THEN            reduce using rule 46 (SE -> LHS EQUALS AE .)
    RBRACKET        reduce using rule 46 (SE -> LHS EQUALS AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112

  ! PLUS            [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! MINUS           [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! MULT            [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! DIVIDE          [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! MOD             [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! GREATERTHAN     [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! GREATEROREQUAL  [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! LESSTHAN        [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! LESSOREQUAL     [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! ISEQUAL         [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! NOTEQUAL        [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! AND             [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]
  ! OR              [ reduce using rule 46 (SE -> LHS EQUALS AE .) ]


state 133

    (68) Primary -> LPAREN AE RPAREN .

    DOT             reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    LBRACKET        reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    PLUS            reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    MINUS           reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    MULT            reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    DIVIDE          reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    MOD             reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    GREATERTHAN     reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    GREATEROREQUAL  reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    LESSTHAN        reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    LESSOREQUAL     reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    ISEQUAL         reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    NOTEQUAL        reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    AND             reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    OR              reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    SCOLON          reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    DO              reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    RPAREN          reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    THEN            reduce using rule 68 (Primary -> LPAREN AE RPAREN .)
    RBRACKET        reduce using rule 68 (Primary -> LPAREN AE RPAREN .)


state 134

    (26) FunctionCall -> ID LPAREN Args . RPAREN

    RPAREN          shift and go to state 162


state 135

    (28) Args -> empty .

    RPAREN          reduce using rule 28 (Args -> empty .)


state 136

    (27) Args -> AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    RPAREN          reduce using rule 27 (Args -> AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 137

    (45) matchedstmt -> IF AE THEN . matchedstmt ELSE matchedstmt
    (43) openstmt -> IF AE THEN . stmt
    (44) openstmt -> IF AE THEN . matchedstmt ELSE openstmt
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (32) stmt -> . matchedstmt
    (33) stmt -> . openstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (43) openstmt -> . IF AE THEN stmt
    (44) openstmt -> . IF AE THEN matchedstmt ELSE openstmt
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    IF              shift and go to state 59
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    for                            shift and go to state 42
    FunctionCall                   shift and go to state 47
    FieldAccess                    shift and go to state 62
    stmt                           shift and go to state 163
    Primary                        shift and go to state 34
    doWhile                        shift and go to state 35
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    Block                          shift and go to state 58
    Print                          shift and go to state 38
    matchedstmt                    shift and go to state 164
    openstmt                       shift and go to state 39
    ReturnOpt                      shift and go to state 56
    ArrayAccess                    shift and go to state 55
    SE                             shift and go to state 66

state 138

    (90) Block -> LBRACE seen Extension . RBRACE

    RBRACE          shift and go to state 165


state 139

    (22) FunDecl -> Type ID LPAREN fseen FormalOpt RPAREN stmt .

    CLASS           reduce using rule 22 (FunDecl -> Type ID LPAREN fseen FormalOpt RPAREN stmt .)
    INT             reduce using rule 22 (FunDecl -> Type ID LPAREN fseen FormalOpt RPAREN stmt .)
    BOOL            reduce using rule 22 (FunDecl -> Type ID LPAREN fseen FormalOpt RPAREN stmt .)
    ID              reduce using rule 22 (FunDecl -> Type ID LPAREN fseen FormalOpt RPAREN stmt .)
    VOID            reduce using rule 22 (FunDecl -> Type ID LPAREN fseen FormalOpt RPAREN stmt .)
    $end            reduce using rule 22 (FunDecl -> Type ID LPAREN fseen FormalOpt RPAREN stmt .)


state 140

    (89) DimExpr -> LBRACKET . AE RBRACKET
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AE                             shift and go to state 166
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    FieldAccess                    shift and go to state 77
    FunctionCall                   shift and go to state 47
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 141

    (87) AE -> NEW Type DimExpr . DimStar
    (21) DimStar -> . LBRACKET RBRACKET
    (30) DimStar -> . empty
    (31) DimStar -> . LBRACKET RBRACKET DimStar
    (4) empty -> .

    LBRACKET        shift and go to state 21
    PLUS            reduce using rule 4 (empty -> .)
    MINUS           reduce using rule 4 (empty -> .)
    MULT            reduce using rule 4 (empty -> .)
    DIVIDE          reduce using rule 4 (empty -> .)
    MOD             reduce using rule 4 (empty -> .)
    GREATERTHAN     reduce using rule 4 (empty -> .)
    GREATEROREQUAL  reduce using rule 4 (empty -> .)
    LESSTHAN        reduce using rule 4 (empty -> .)
    LESSOREQUAL     reduce using rule 4 (empty -> .)
    ISEQUAL         reduce using rule 4 (empty -> .)
    NOTEQUAL        reduce using rule 4 (empty -> .)
    AND             reduce using rule 4 (empty -> .)
    OR              reduce using rule 4 (empty -> .)
    SCOLON          reduce using rule 4 (empty -> .)
    DO              reduce using rule 4 (empty -> .)
    RPAREN          reduce using rule 4 (empty -> .)
    THEN            reduce using rule 4 (empty -> .)
    RBRACKET        reduce using rule 4 (empty -> .)

    DimStar                        shift and go to state 167
    empty                          shift and go to state 23

state 142

    (82) AE -> AE AND AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATEROREQUAL resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for LESSOREQUAL resolved as shift
  ! shift/reduce conflict for ISEQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SCOLON          reduce using rule 82 (AE -> AE AND AE .)
    DO              reduce using rule 82 (AE -> AE AND AE .)
    RPAREN          reduce using rule 82 (AE -> AE AND AE .)
    THEN            reduce using rule 82 (AE -> AE AND AE .)
    RBRACKET        reduce using rule 82 (AE -> AE AND AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112

  ! PLUS            [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! MINUS           [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! MULT            [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! DIVIDE          [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! MOD             [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! GREATERTHAN     [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! GREATEROREQUAL  [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! LESSTHAN        [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! LESSOREQUAL     [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! ISEQUAL         [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! NOTEQUAL        [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! AND             [ reduce using rule 82 (AE -> AE AND AE .) ]
  ! OR              [ reduce using rule 82 (AE -> AE AND AE .) ]


state 143

    (81) AE -> AE NOTEQUAL AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    GREATERTHAN     reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    GREATEROREQUAL  reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    LESSTHAN        reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    LESSOREQUAL     reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    ISEQUAL         reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    NOTEQUAL        reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    AND             reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    OR              reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    SCOLON          reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    DO              reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    RPAREN          reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    THEN            reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    RBRACKET        reduce using rule 81 (AE -> AE NOTEQUAL AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119

  ! PLUS            [ reduce using rule 81 (AE -> AE NOTEQUAL AE .) ]
  ! MINUS           [ reduce using rule 81 (AE -> AE NOTEQUAL AE .) ]
  ! MULT            [ reduce using rule 81 (AE -> AE NOTEQUAL AE .) ]
  ! DIVIDE          [ reduce using rule 81 (AE -> AE NOTEQUAL AE .) ]
  ! MOD             [ reduce using rule 81 (AE -> AE NOTEQUAL AE .) ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 144

    (79) AE -> AE LESSOREQUAL AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    GREATERTHAN     reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    GREATEROREQUAL  reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    LESSTHAN        reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    LESSOREQUAL     reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    ISEQUAL         reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    NOTEQUAL        reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    AND             reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    OR              reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    SCOLON          reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    DO              reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    RPAREN          reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    THEN            reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    RBRACKET        reduce using rule 79 (AE -> AE LESSOREQUAL AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119

  ! PLUS            [ reduce using rule 79 (AE -> AE LESSOREQUAL AE .) ]
  ! MINUS           [ reduce using rule 79 (AE -> AE LESSOREQUAL AE .) ]
  ! MULT            [ reduce using rule 79 (AE -> AE LESSOREQUAL AE .) ]
  ! DIVIDE          [ reduce using rule 79 (AE -> AE LESSOREQUAL AE .) ]
  ! MOD             [ reduce using rule 79 (AE -> AE LESSOREQUAL AE .) ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 145

    (73) AE -> AE DIVIDE AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    PLUS            reduce using rule 73 (AE -> AE DIVIDE AE .)
    MINUS           reduce using rule 73 (AE -> AE DIVIDE AE .)
    MULT            reduce using rule 73 (AE -> AE DIVIDE AE .)
    DIVIDE          reduce using rule 73 (AE -> AE DIVIDE AE .)
    MOD             reduce using rule 73 (AE -> AE DIVIDE AE .)
    GREATERTHAN     reduce using rule 73 (AE -> AE DIVIDE AE .)
    GREATEROREQUAL  reduce using rule 73 (AE -> AE DIVIDE AE .)
    LESSTHAN        reduce using rule 73 (AE -> AE DIVIDE AE .)
    LESSOREQUAL     reduce using rule 73 (AE -> AE DIVIDE AE .)
    ISEQUAL         reduce using rule 73 (AE -> AE DIVIDE AE .)
    NOTEQUAL        reduce using rule 73 (AE -> AE DIVIDE AE .)
    AND             reduce using rule 73 (AE -> AE DIVIDE AE .)
    OR              reduce using rule 73 (AE -> AE DIVIDE AE .)
    SCOLON          reduce using rule 73 (AE -> AE DIVIDE AE .)
    DO              reduce using rule 73 (AE -> AE DIVIDE AE .)
    RPAREN          reduce using rule 73 (AE -> AE DIVIDE AE .)
    THEN            reduce using rule 73 (AE -> AE DIVIDE AE .)
    RBRACKET        reduce using rule 73 (AE -> AE DIVIDE AE .)

  ! PLUS            [ shift and go to state 114 ]
  ! MINUS           [ shift and go to state 117 ]
  ! MULT            [ shift and go to state 118 ]
  ! DIVIDE          [ shift and go to state 110 ]
  ! MOD             [ shift and go to state 119 ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 146

    (80) AE -> AE ISEQUAL AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    GREATERTHAN     reduce using rule 80 (AE -> AE ISEQUAL AE .)
    GREATEROREQUAL  reduce using rule 80 (AE -> AE ISEQUAL AE .)
    LESSTHAN        reduce using rule 80 (AE -> AE ISEQUAL AE .)
    LESSOREQUAL     reduce using rule 80 (AE -> AE ISEQUAL AE .)
    ISEQUAL         reduce using rule 80 (AE -> AE ISEQUAL AE .)
    NOTEQUAL        reduce using rule 80 (AE -> AE ISEQUAL AE .)
    AND             reduce using rule 80 (AE -> AE ISEQUAL AE .)
    OR              reduce using rule 80 (AE -> AE ISEQUAL AE .)
    SCOLON          reduce using rule 80 (AE -> AE ISEQUAL AE .)
    DO              reduce using rule 80 (AE -> AE ISEQUAL AE .)
    RPAREN          reduce using rule 80 (AE -> AE ISEQUAL AE .)
    THEN            reduce using rule 80 (AE -> AE ISEQUAL AE .)
    RBRACKET        reduce using rule 80 (AE -> AE ISEQUAL AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119

  ! PLUS            [ reduce using rule 80 (AE -> AE ISEQUAL AE .) ]
  ! MINUS           [ reduce using rule 80 (AE -> AE ISEQUAL AE .) ]
  ! MULT            [ reduce using rule 80 (AE -> AE ISEQUAL AE .) ]
  ! DIVIDE          [ reduce using rule 80 (AE -> AE ISEQUAL AE .) ]
  ! MOD             [ reduce using rule 80 (AE -> AE ISEQUAL AE .) ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 147

    (83) AE -> AE OR AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATEROREQUAL resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for LESSOREQUAL resolved as shift
  ! shift/reduce conflict for ISEQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SCOLON          reduce using rule 83 (AE -> AE OR AE .)
    DO              reduce using rule 83 (AE -> AE OR AE .)
    RPAREN          reduce using rule 83 (AE -> AE OR AE .)
    THEN            reduce using rule 83 (AE -> AE OR AE .)
    RBRACKET        reduce using rule 83 (AE -> AE OR AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112

  ! PLUS            [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! MINUS           [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! MULT            [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! DIVIDE          [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! MOD             [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! GREATERTHAN     [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! GREATEROREQUAL  [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! LESSTHAN        [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! LESSOREQUAL     [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! ISEQUAL         [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! NOTEQUAL        [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! AND             [ reduce using rule 83 (AE -> AE OR AE .) ]
  ! OR              [ reduce using rule 83 (AE -> AE OR AE .) ]


state 148

    (78) AE -> AE LESSTHAN AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    GREATERTHAN     reduce using rule 78 (AE -> AE LESSTHAN AE .)
    GREATEROREQUAL  reduce using rule 78 (AE -> AE LESSTHAN AE .)
    LESSTHAN        reduce using rule 78 (AE -> AE LESSTHAN AE .)
    LESSOREQUAL     reduce using rule 78 (AE -> AE LESSTHAN AE .)
    ISEQUAL         reduce using rule 78 (AE -> AE LESSTHAN AE .)
    NOTEQUAL        reduce using rule 78 (AE -> AE LESSTHAN AE .)
    AND             reduce using rule 78 (AE -> AE LESSTHAN AE .)
    OR              reduce using rule 78 (AE -> AE LESSTHAN AE .)
    SCOLON          reduce using rule 78 (AE -> AE LESSTHAN AE .)
    DO              reduce using rule 78 (AE -> AE LESSTHAN AE .)
    RPAREN          reduce using rule 78 (AE -> AE LESSTHAN AE .)
    THEN            reduce using rule 78 (AE -> AE LESSTHAN AE .)
    RBRACKET        reduce using rule 78 (AE -> AE LESSTHAN AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119

  ! PLUS            [ reduce using rule 78 (AE -> AE LESSTHAN AE .) ]
  ! MINUS           [ reduce using rule 78 (AE -> AE LESSTHAN AE .) ]
  ! MULT            [ reduce using rule 78 (AE -> AE LESSTHAN AE .) ]
  ! DIVIDE          [ reduce using rule 78 (AE -> AE LESSTHAN AE .) ]
  ! MOD             [ reduce using rule 78 (AE -> AE LESSTHAN AE .) ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 149

    (70) AE -> AE PLUS AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    PLUS            reduce using rule 70 (AE -> AE PLUS AE .)
    MINUS           reduce using rule 70 (AE -> AE PLUS AE .)
    GREATERTHAN     reduce using rule 70 (AE -> AE PLUS AE .)
    GREATEROREQUAL  reduce using rule 70 (AE -> AE PLUS AE .)
    LESSTHAN        reduce using rule 70 (AE -> AE PLUS AE .)
    LESSOREQUAL     reduce using rule 70 (AE -> AE PLUS AE .)
    ISEQUAL         reduce using rule 70 (AE -> AE PLUS AE .)
    NOTEQUAL        reduce using rule 70 (AE -> AE PLUS AE .)
    AND             reduce using rule 70 (AE -> AE PLUS AE .)
    OR              reduce using rule 70 (AE -> AE PLUS AE .)
    SCOLON          reduce using rule 70 (AE -> AE PLUS AE .)
    DO              reduce using rule 70 (AE -> AE PLUS AE .)
    RPAREN          reduce using rule 70 (AE -> AE PLUS AE .)
    THEN            reduce using rule 70 (AE -> AE PLUS AE .)
    RBRACKET        reduce using rule 70 (AE -> AE PLUS AE .)
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119

  ! MULT            [ reduce using rule 70 (AE -> AE PLUS AE .) ]
  ! DIVIDE          [ reduce using rule 70 (AE -> AE PLUS AE .) ]
  ! MOD             [ reduce using rule 70 (AE -> AE PLUS AE .) ]
  ! PLUS            [ shift and go to state 114 ]
  ! MINUS           [ shift and go to state 117 ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 150

    (77) AE -> AE GREATEROREQUAL AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    GREATERTHAN     reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    GREATEROREQUAL  reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    LESSTHAN        reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    LESSOREQUAL     reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    ISEQUAL         reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    NOTEQUAL        reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    AND             reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    OR              reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    SCOLON          reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    DO              reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    RPAREN          reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    THEN            reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    RBRACKET        reduce using rule 77 (AE -> AE GREATEROREQUAL AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119

  ! PLUS            [ reduce using rule 77 (AE -> AE GREATEROREQUAL AE .) ]
  ! MINUS           [ reduce using rule 77 (AE -> AE GREATEROREQUAL AE .) ]
  ! MULT            [ reduce using rule 77 (AE -> AE GREATEROREQUAL AE .) ]
  ! DIVIDE          [ reduce using rule 77 (AE -> AE GREATEROREQUAL AE .) ]
  ! MOD             [ reduce using rule 77 (AE -> AE GREATEROREQUAL AE .) ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 151

    (76) AE -> AE GREATERTHAN AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    GREATERTHAN     reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    GREATEROREQUAL  reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    LESSTHAN        reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    LESSOREQUAL     reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    ISEQUAL         reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    NOTEQUAL        reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    AND             reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    OR              reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    SCOLON          reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    DO              reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    RPAREN          reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    THEN            reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    RBRACKET        reduce using rule 76 (AE -> AE GREATERTHAN AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119

  ! PLUS            [ reduce using rule 76 (AE -> AE GREATERTHAN AE .) ]
  ! MINUS           [ reduce using rule 76 (AE -> AE GREATERTHAN AE .) ]
  ! MULT            [ reduce using rule 76 (AE -> AE GREATERTHAN AE .) ]
  ! DIVIDE          [ reduce using rule 76 (AE -> AE GREATERTHAN AE .) ]
  ! MOD             [ reduce using rule 76 (AE -> AE GREATERTHAN AE .) ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 152

    (71) AE -> AE MINUS AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    PLUS            reduce using rule 71 (AE -> AE MINUS AE .)
    MINUS           reduce using rule 71 (AE -> AE MINUS AE .)
    GREATERTHAN     reduce using rule 71 (AE -> AE MINUS AE .)
    GREATEROREQUAL  reduce using rule 71 (AE -> AE MINUS AE .)
    LESSTHAN        reduce using rule 71 (AE -> AE MINUS AE .)
    LESSOREQUAL     reduce using rule 71 (AE -> AE MINUS AE .)
    ISEQUAL         reduce using rule 71 (AE -> AE MINUS AE .)
    NOTEQUAL        reduce using rule 71 (AE -> AE MINUS AE .)
    AND             reduce using rule 71 (AE -> AE MINUS AE .)
    OR              reduce using rule 71 (AE -> AE MINUS AE .)
    SCOLON          reduce using rule 71 (AE -> AE MINUS AE .)
    DO              reduce using rule 71 (AE -> AE MINUS AE .)
    RPAREN          reduce using rule 71 (AE -> AE MINUS AE .)
    THEN            reduce using rule 71 (AE -> AE MINUS AE .)
    RBRACKET        reduce using rule 71 (AE -> AE MINUS AE .)
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119

  ! MULT            [ reduce using rule 71 (AE -> AE MINUS AE .) ]
  ! DIVIDE          [ reduce using rule 71 (AE -> AE MINUS AE .) ]
  ! MOD             [ reduce using rule 71 (AE -> AE MINUS AE .) ]
  ! PLUS            [ shift and go to state 114 ]
  ! MINUS           [ shift and go to state 117 ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 153

    (72) AE -> AE MULT AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    PLUS            reduce using rule 72 (AE -> AE MULT AE .)
    MINUS           reduce using rule 72 (AE -> AE MULT AE .)
    MULT            reduce using rule 72 (AE -> AE MULT AE .)
    DIVIDE          reduce using rule 72 (AE -> AE MULT AE .)
    MOD             reduce using rule 72 (AE -> AE MULT AE .)
    GREATERTHAN     reduce using rule 72 (AE -> AE MULT AE .)
    GREATEROREQUAL  reduce using rule 72 (AE -> AE MULT AE .)
    LESSTHAN        reduce using rule 72 (AE -> AE MULT AE .)
    LESSOREQUAL     reduce using rule 72 (AE -> AE MULT AE .)
    ISEQUAL         reduce using rule 72 (AE -> AE MULT AE .)
    NOTEQUAL        reduce using rule 72 (AE -> AE MULT AE .)
    AND             reduce using rule 72 (AE -> AE MULT AE .)
    OR              reduce using rule 72 (AE -> AE MULT AE .)
    SCOLON          reduce using rule 72 (AE -> AE MULT AE .)
    DO              reduce using rule 72 (AE -> AE MULT AE .)
    RPAREN          reduce using rule 72 (AE -> AE MULT AE .)
    THEN            reduce using rule 72 (AE -> AE MULT AE .)
    RBRACKET        reduce using rule 72 (AE -> AE MULT AE .)

  ! PLUS            [ shift and go to state 114 ]
  ! MINUS           [ shift and go to state 117 ]
  ! MULT            [ shift and go to state 118 ]
  ! DIVIDE          [ shift and go to state 110 ]
  ! MOD             [ shift and go to state 119 ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 154

    (74) AE -> AE MOD AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    PLUS            reduce using rule 74 (AE -> AE MOD AE .)
    MINUS           reduce using rule 74 (AE -> AE MOD AE .)
    MULT            reduce using rule 74 (AE -> AE MOD AE .)
    DIVIDE          reduce using rule 74 (AE -> AE MOD AE .)
    MOD             reduce using rule 74 (AE -> AE MOD AE .)
    GREATERTHAN     reduce using rule 74 (AE -> AE MOD AE .)
    GREATEROREQUAL  reduce using rule 74 (AE -> AE MOD AE .)
    LESSTHAN        reduce using rule 74 (AE -> AE MOD AE .)
    LESSOREQUAL     reduce using rule 74 (AE -> AE MOD AE .)
    ISEQUAL         reduce using rule 74 (AE -> AE MOD AE .)
    NOTEQUAL        reduce using rule 74 (AE -> AE MOD AE .)
    AND             reduce using rule 74 (AE -> AE MOD AE .)
    OR              reduce using rule 74 (AE -> AE MOD AE .)
    SCOLON          reduce using rule 74 (AE -> AE MOD AE .)
    DO              reduce using rule 74 (AE -> AE MOD AE .)
    RPAREN          reduce using rule 74 (AE -> AE MOD AE .)
    THEN            reduce using rule 74 (AE -> AE MOD AE .)
    RBRACKET        reduce using rule 74 (AE -> AE MOD AE .)

  ! PLUS            [ shift and go to state 114 ]
  ! MINUS           [ shift and go to state 117 ]
  ! MULT            [ shift and go to state 118 ]
  ! DIVIDE          [ shift and go to state 110 ]
  ! MOD             [ shift and go to state 119 ]
  ! GREATERTHAN     [ shift and go to state 116 ]
  ! GREATEROREQUAL  [ shift and go to state 115 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! LESSOREQUAL     [ shift and go to state 109 ]
  ! ISEQUAL         [ shift and go to state 111 ]
  ! NOTEQUAL        [ shift and go to state 108 ]
  ! AND             [ shift and go to state 107 ]
  ! OR              [ shift and go to state 112 ]


state 155

    (55) doWhile -> DO matchedstmt WHILE AE . SCOLON
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    SCOLON          shift and go to state 168
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 156

    (45) matchedstmt -> IF AE THEN . matchedstmt ELSE matchedstmt
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    IF              shift and go to state 82
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    for                            shift and go to state 42
    FunctionCall                   shift and go to state 47
    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    doWhile                        shift and go to state 35
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    SE                             shift and go to state 66
    Print                          shift and go to state 38
    matchedstmt                    shift and go to state 169
    ArrayAccess                    shift and go to state 55
    ReturnOpt                      shift and go to state 56
    Block                          shift and go to state 58

state 157

    (88) ArrayAccess -> Primary LBRACKET AE RBRACKET .

    EQUALS          reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    DOT             reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    LBRACKET        reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    PLUS            reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    MINUS           reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    MULT            reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    DIVIDE          reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    MOD             reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    GREATERTHAN     reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    GREATEROREQUAL  reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    LESSTHAN        reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    LESSOREQUAL     reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    ISEQUAL         reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    NOTEQUAL        reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    AND             reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    OR              reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    SCOLON          reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    DO              reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    RPAREN          reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    THEN            reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)
    RBRACKET        reduce using rule 88 (ArrayAccess -> Primary LBRACKET AE RBRACKET .)


state 158

    (54) While -> WHILE AE DO matchedstmt .

    IF              reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    INCREMENT       reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    DECREMENT       reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    PRINT           reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    WHILE           reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    LBRACE          reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    DO              reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    FOR             reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    RETURN          reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    ID              reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    INPUT           reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    TRUE            reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    FALSE           reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    LPAREN          reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    NUMBER          reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    NEW             reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    RBRACE          reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    CLASS           reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    INT             reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    BOOL            reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    VOID            reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    $end            reduce using rule 54 (While -> WHILE AE DO matchedstmt .)
    ELSE            reduce using rule 54 (While -> WHILE AE DO matchedstmt .)


state 159

    (56) for -> FOR LPAREN SEopt SCOLON . AEopt SCOLON SEopt RPAREN matchedstmt
    (59) AEopt -> . AE
    (60) AEopt -> . empty
    (61) AE -> . SE
    (62) AE -> . Primary
    (70) AE -> . AE PLUS AE
    (71) AE -> . AE MINUS AE
    (72) AE -> . AE MULT AE
    (73) AE -> . AE DIVIDE AE
    (74) AE -> . AE MOD AE
    (75) AE -> . MINUS AE
    (76) AE -> . AE GREATERTHAN AE
    (77) AE -> . AE GREATEROREQUAL AE
    (78) AE -> . AE LESSTHAN AE
    (79) AE -> . AE LESSOREQUAL AE
    (80) AE -> . AE ISEQUAL AE
    (81) AE -> . AE NOTEQUAL AE
    (82) AE -> . AE AND AE
    (83) AE -> . AE OR AE
    (84) AE -> . NOT AE
    (87) AE -> . NEW Type DimExpr DimStar
    (4) empty -> .
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (26) FunctionCall -> . ID LPAREN Args RPAREN
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET

    MINUS           shift and go to state 73
    NOT             shift and go to state 79
    NEW             shift and go to state 72
    SCOLON          reduce using rule 4 (empty -> .)
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    ID              shift and go to state 76

    AEopt                          shift and go to state 172
    AE                             shift and go to state 171
    FunctionCall                   shift and go to state 47
    Primary                        shift and go to state 78
    LHS                            shift and go to state 52
    empty                          shift and go to state 170
    FieldAccess                    shift and go to state 77
    ArrayAccess                    shift and go to state 75
    SE                             shift and go to state 80

state 160

    (86) Primary -> NEW ID LPAREN RPAREN .

    DOT             reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    LBRACKET        reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    PLUS            reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    MINUS           reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    MULT            reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    MOD             reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    GREATERTHAN     reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    GREATEROREQUAL  reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    LESSTHAN        reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    LESSOREQUAL     reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    ISEQUAL         reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    AND             reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    OR              reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    SCOLON          reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    DO              reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    RPAREN          reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    THEN            reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 86 (Primary -> NEW ID LPAREN RPAREN .)


state 161

    (53) Print -> PRINT LPAREN AE RPAREN . SCOLON

    SCOLON          shift and go to state 173


state 162

    (26) FunctionCall -> ID LPAREN Args RPAREN .

    DOT             reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    LBRACKET        reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    RPAREN          reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    PLUS            reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    MINUS           reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    MULT            reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    DIVIDE          reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    MOD             reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    GREATERTHAN     reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    GREATEROREQUAL  reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    LESSTHAN        reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    LESSOREQUAL     reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    ISEQUAL         reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    NOTEQUAL        reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    AND             reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    OR              reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    SCOLON          reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    DO              reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    THEN            reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)
    RBRACKET        reduce using rule 26 (FunctionCall -> ID LPAREN Args RPAREN .)


state 163

    (43) openstmt -> IF AE THEN stmt .

    IF              reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    INCREMENT       reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    DECREMENT       reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    PRINT           reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    WHILE           reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    LBRACE          reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    DO              reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    FOR             reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    RETURN          reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    ID              reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    INPUT           reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    TRUE            reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    FALSE           reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    LPAREN          reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    NUMBER          reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    NEW             reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    RBRACE          reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    CLASS           reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    INT             reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    BOOL            reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    VOID            reduce using rule 43 (openstmt -> IF AE THEN stmt .)
    $end            reduce using rule 43 (openstmt -> IF AE THEN stmt .)


state 164

    (45) matchedstmt -> IF AE THEN matchedstmt . ELSE matchedstmt
    (44) openstmt -> IF AE THEN matchedstmt . ELSE openstmt
    (32) stmt -> matchedstmt .

    ELSE            shift and go to state 174
    IF              reduce using rule 32 (stmt -> matchedstmt .)
    INCREMENT       reduce using rule 32 (stmt -> matchedstmt .)
    DECREMENT       reduce using rule 32 (stmt -> matchedstmt .)
    PRINT           reduce using rule 32 (stmt -> matchedstmt .)
    WHILE           reduce using rule 32 (stmt -> matchedstmt .)
    LBRACE          reduce using rule 32 (stmt -> matchedstmt .)
    DO              reduce using rule 32 (stmt -> matchedstmt .)
    FOR             reduce using rule 32 (stmt -> matchedstmt .)
    RETURN          reduce using rule 32 (stmt -> matchedstmt .)
    ID              reduce using rule 32 (stmt -> matchedstmt .)
    INPUT           reduce using rule 32 (stmt -> matchedstmt .)
    TRUE            reduce using rule 32 (stmt -> matchedstmt .)
    FALSE           reduce using rule 32 (stmt -> matchedstmt .)
    LPAREN          reduce using rule 32 (stmt -> matchedstmt .)
    NUMBER          reduce using rule 32 (stmt -> matchedstmt .)
    NEW             reduce using rule 32 (stmt -> matchedstmt .)
    RBRACE          reduce using rule 32 (stmt -> matchedstmt .)
    CLASS           reduce using rule 32 (stmt -> matchedstmt .)
    INT             reduce using rule 32 (stmt -> matchedstmt .)
    BOOL            reduce using rule 32 (stmt -> matchedstmt .)
    VOID            reduce using rule 32 (stmt -> matchedstmt .)
    $end            reduce using rule 32 (stmt -> matchedstmt .)


state 165

    (90) Block -> LBRACE seen Extension RBRACE .

    IF              reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    INCREMENT       reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    DECREMENT       reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    PRINT           reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    WHILE           reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    LBRACE          reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    DO              reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    FOR             reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    RETURN          reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    ID              reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    INPUT           reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    TRUE            reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    FALSE           reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    LPAREN          reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    NUMBER          reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    NEW             reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    RBRACE          reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    CLASS           reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    INT             reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    BOOL            reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    VOID            reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    $end            reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)
    ELSE            reduce using rule 90 (Block -> LBRACE seen Extension RBRACE .)


state 166

    (89) DimExpr -> LBRACKET AE . RBRACKET
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    RBRACKET        shift and go to state 175
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 167

    (87) AE -> NEW Type DimExpr DimStar .

    PLUS            reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    MINUS           reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    MULT            reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    DIVIDE          reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    MOD             reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    GREATERTHAN     reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    GREATEROREQUAL  reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    LESSTHAN        reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    LESSOREQUAL     reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    ISEQUAL         reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    NOTEQUAL        reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    AND             reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    OR              reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    SCOLON          reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    DO              reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    RPAREN          reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    THEN            reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)
    RBRACKET        reduce using rule 87 (AE -> NEW Type DimExpr DimStar .)


state 168

    (55) doWhile -> DO matchedstmt WHILE AE SCOLON .

    IF              reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    INCREMENT       reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    DECREMENT       reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    PRINT           reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    WHILE           reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    LBRACE          reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    DO              reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    FOR             reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    RETURN          reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    ID              reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    INPUT           reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    TRUE            reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    FALSE           reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    LPAREN          reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    NUMBER          reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    NEW             reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    RBRACE          reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    CLASS           reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    INT             reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    BOOL            reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    VOID            reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    $end            reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)
    ELSE            reduce using rule 55 (doWhile -> DO matchedstmt WHILE AE SCOLON .)


state 169

    (45) matchedstmt -> IF AE THEN matchedstmt . ELSE matchedstmt

    ELSE            shift and go to state 176


state 170

    (60) AEopt -> empty .

    SCOLON          reduce using rule 60 (AEopt -> empty .)


state 171

    (59) AEopt -> AE .
    (70) AE -> AE . PLUS AE
    (71) AE -> AE . MINUS AE
    (72) AE -> AE . MULT AE
    (73) AE -> AE . DIVIDE AE
    (74) AE -> AE . MOD AE
    (76) AE -> AE . GREATERTHAN AE
    (77) AE -> AE . GREATEROREQUAL AE
    (78) AE -> AE . LESSTHAN AE
    (79) AE -> AE . LESSOREQUAL AE
    (80) AE -> AE . ISEQUAL AE
    (81) AE -> AE . NOTEQUAL AE
    (82) AE -> AE . AND AE
    (83) AE -> AE . OR AE

    SCOLON          reduce using rule 59 (AEopt -> AE .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 117
    MULT            shift and go to state 118
    DIVIDE          shift and go to state 110
    MOD             shift and go to state 119
    GREATERTHAN     shift and go to state 116
    GREATEROREQUAL  shift and go to state 115
    LESSTHAN        shift and go to state 113
    LESSOREQUAL     shift and go to state 109
    ISEQUAL         shift and go to state 111
    NOTEQUAL        shift and go to state 108
    AND             shift and go to state 107
    OR              shift and go to state 112


state 172

    (56) for -> FOR LPAREN SEopt SCOLON AEopt . SCOLON SEopt RPAREN matchedstmt

    SCOLON          shift and go to state 177


state 173

    (53) Print -> PRINT LPAREN AE RPAREN SCOLON .

    CLASS           reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    INT             reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    BOOL            reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    ID              reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    VOID            reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    $end            reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    IF              reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    INCREMENT       reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    DECREMENT       reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    PRINT           reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    WHILE           reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    LBRACE          reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    DO              reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    FOR             reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    RETURN          reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    INPUT           reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    TRUE            reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    FALSE           reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    LPAREN          reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    NUMBER          reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    NEW             reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    RBRACE          reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)
    ELSE            reduce using rule 53 (Print -> PRINT LPAREN AE RPAREN SCOLON .)


state 174

    (45) matchedstmt -> IF AE THEN matchedstmt ELSE . matchedstmt
    (44) openstmt -> IF AE THEN matchedstmt ELSE . openstmt
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (43) openstmt -> . IF AE THEN stmt
    (44) openstmt -> . IF AE THEN matchedstmt ELSE openstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    IF              shift and go to state 59
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    for                            shift and go to state 42
    FunctionCall                   shift and go to state 47
    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    doWhile                        shift and go to state 35
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    Block                          shift and go to state 58
    Print                          shift and go to state 38
    matchedstmt                    shift and go to state 179
    openstmt                       shift and go to state 178
    ReturnOpt                      shift and go to state 56
    ArrayAccess                    shift and go to state 55
    SE                             shift and go to state 66

state 175

    (89) DimExpr -> LBRACKET AE RBRACKET .

    LBRACKET        reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    PLUS            reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    MINUS           reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    MULT            reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    DIVIDE          reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    MOD             reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    GREATERTHAN     reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    GREATEROREQUAL  reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    LESSTHAN        reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    LESSOREQUAL     reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    ISEQUAL         reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    NOTEQUAL        reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    AND             reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    OR              reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    SCOLON          reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    DO              reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    RPAREN          reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    THEN            reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)
    RBRACKET        reduce using rule 89 (DimExpr -> LBRACKET AE RBRACKET .)


state 176

    (45) matchedstmt -> IF AE THEN matchedstmt ELSE . matchedstmt
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    IF              shift and go to state 82
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    for                            shift and go to state 42
    FunctionCall                   shift and go to state 47
    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    doWhile                        shift and go to state 35
    While                          shift and go to state 51
    LHS                            shift and go to state 52
    SE                             shift and go to state 66
    Print                          shift and go to state 38
    matchedstmt                    shift and go to state 179
    ArrayAccess                    shift and go to state 55
    ReturnOpt                      shift and go to state 56
    Block                          shift and go to state 58

state 177

    (56) for -> FOR LPAREN SEopt SCOLON AEopt SCOLON . SEopt RPAREN matchedstmt
    (57) SEopt -> . SE
    (58) SEopt -> . empty
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (4) empty -> .
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    RPAREN          reduce using rule 4 (empty -> .)
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    FunctionCall                   shift and go to state 47
    FieldAccess                    shift and go to state 62
    Primary                        shift and go to state 34
    SEopt                          shift and go to state 180
    LHS                            shift and go to state 52
    SE                             shift and go to state 129
    ArrayAccess                    shift and go to state 55
    empty                          shift and go to state 128

state 178

    (44) openstmt -> IF AE THEN matchedstmt ELSE openstmt .

    IF              reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    INCREMENT       reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    DECREMENT       reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    PRINT           reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    WHILE           reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    LBRACE          reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    DO              reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    FOR             reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    RETURN          reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    ID              reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    INPUT           reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    TRUE            reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    FALSE           reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    LPAREN          reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    NUMBER          reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    NEW             reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    RBRACE          reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    CLASS           reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    INT             reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    BOOL            reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    VOID            reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)
    $end            reduce using rule 44 (openstmt -> IF AE THEN matchedstmt ELSE openstmt .)


state 179

    (45) matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .

    IF              reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    INCREMENT       reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    DECREMENT       reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    PRINT           reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    WHILE           reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    LBRACE          reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    DO              reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    FOR             reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    RETURN          reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    ID              reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    INPUT           reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    TRUE            reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    FALSE           reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    LPAREN          reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    NUMBER          reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    NEW             reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    RBRACE          reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    CLASS           reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    INT             reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    BOOL            reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    VOID            reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    $end            reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)
    ELSE            reduce using rule 45 (matchedstmt -> IF AE THEN matchedstmt ELSE matchedstmt .)


state 180

    (56) for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt . RPAREN matchedstmt

    RPAREN          shift and go to state 181


state 181

    (56) for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN . matchedstmt
    (34) matchedstmt -> . SE SCOLON
    (35) matchedstmt -> . Print
    (36) matchedstmt -> . While
    (37) matchedstmt -> . Block
    (38) matchedstmt -> . doWhile
    (39) matchedstmt -> . for
    (40) matchedstmt -> . ReturnOpt SCOLON
    (45) matchedstmt -> . IF AE THEN matchedstmt ELSE matchedstmt
    (46) SE -> . LHS EQUALS AE
    (51) SE -> . INCREMENT LHS
    (52) SE -> . DECREMENT LHS
    (53) Print -> . PRINT LPAREN AE RPAREN SCOLON
    (54) While -> . WHILE AE DO matchedstmt
    (90) Block -> . LBRACE seen Extension RBRACE
    (55) doWhile -> . DO matchedstmt WHILE AE SCOLON
    (56) for -> . FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt
    (41) ReturnOpt -> . RETURN AE
    (42) ReturnOpt -> . RETURN VOID
    (47) LHS -> . FieldAccess
    (48) LHS -> . ArrayAccess
    (49) FieldAccess -> . ID
    (50) FieldAccess -> . Primary DOT ID
    (88) ArrayAccess -> . Primary LBRACKET AE RBRACKET
    (63) Primary -> . FieldAccess
    (64) Primary -> . FunctionCall
    (65) Primary -> . INPUT LPAREN RPAREN
    (66) Primary -> . TRUE
    (67) Primary -> . FALSE
    (68) Primary -> . LPAREN AE RPAREN
    (69) Primary -> . NUMBER
    (85) Primary -> . ArrayAccess
    (86) Primary -> . NEW ID LPAREN RPAREN
    (26) FunctionCall -> . ID LPAREN Args RPAREN

    IF              shift and go to state 82
    INCREMENT       shift and go to state 45
    DECREMENT       shift and go to state 65
    PRINT           shift and go to state 46
    WHILE           shift and go to state 36
    LBRACE          shift and go to state 60
    DO              shift and go to state 32
    FOR             shift and go to state 41
    RETURN          shift and go to state 31
    ID              shift and go to state 76
    INPUT           shift and go to state 37
    TRUE            shift and go to state 43
    FALSE           shift and go to state 61
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 33
    NEW             shift and go to state 44

    for                            shift and go to state 42
    FunctionCall                   shift and go to state 47
    FieldAccess                    shift and go to state 62
    While                          shift and go to state 51
    Primary                        shift and go to state 34
    doWhile                        shift and go to state 35
    LHS                            shift and go to state 52
    Block                          shift and go to state 58
    Print                          shift and go to state 38
    matchedstmt                    shift and go to state 182
    ReturnOpt                      shift and go to state 56
    ArrayAccess                    shift and go to state 55
    SE                             shift and go to state 66

state 182

    (56) for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .

    CLASS           reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    INT             reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    BOOL            reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    ID              reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    VOID            reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    $end            reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    IF              reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    INCREMENT       reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    DECREMENT       reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    PRINT           reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    WHILE           reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    LBRACE          reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    DO              reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    FOR             reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    RETURN          reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    INPUT           reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    TRUE            reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    FALSE           reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    LPAREN          reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    NUMBER          reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    NEW             reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    RBRACE          reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)
    ELSE            reduce using rule 56 (for -> FOR LPAREN SEopt SCOLON AEopt SCOLON SEopt RPAREN matchedstmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 132 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 132 resolved as shift
WARNING: shift/reduce conflict for MULT in state 132 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 132 resolved as shift
WARNING: shift/reduce conflict for MOD in state 132 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 132 resolved as shift
WARNING: shift/reduce conflict for GREATEROREQUAL in state 132 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 132 resolved as shift
WARNING: shift/reduce conflict for LESSOREQUAL in state 132 resolved as shift
WARNING: shift/reduce conflict for ISEQUAL in state 132 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 132 resolved as shift
WARNING: shift/reduce conflict for AND in state 132 resolved as shift
WARNING: shift/reduce conflict for OR in state 132 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MULT in state 142 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 142 resolved as shift
WARNING: shift/reduce conflict for MOD in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATEROREQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 142 resolved as shift
WARNING: shift/reduce conflict for LESSOREQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for ISEQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for AND in state 142 resolved as shift
WARNING: shift/reduce conflict for OR in state 142 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MULT in state 147 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 147 resolved as shift
WARNING: shift/reduce conflict for MOD in state 147 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 147 resolved as shift
WARNING: shift/reduce conflict for GREATEROREQUAL in state 147 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 147 resolved as shift
WARNING: shift/reduce conflict for LESSOREQUAL in state 147 resolved as shift
WARNING: shift/reduce conflict for ISEQUAL in state 147 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 147 resolved as shift
WARNING: shift/reduce conflict for AND in state 147 resolved as shift
WARNING: shift/reduce conflict for OR in state 147 resolved as shift
WARNING: reduce/reduce conflict in state 28 resolved using rule (empty -> <empty>)
WARNING: rejected rule (DimStar -> LBRACKET RBRACKET) in state 28
WARNING: reduce/reduce conflict in state 63 resolved using rule (empty -> <empty>)
WARNING: rejected rule (Extension -> VarDecl) in state 63
WARNING: Rule (DimStar -> LBRACKET RBRACKET) is never reduced
WARNING: Rule (Extension -> VarDecl) is never reduced
